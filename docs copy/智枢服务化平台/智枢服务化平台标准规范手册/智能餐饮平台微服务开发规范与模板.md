# 智能餐饮平台微服务开发规范与模板

## 1. 概述

本文档定义了智能餐饮平台微服务开发的规范和模板，旨在确保所有微服务遵循统一的开发标准，提高代码质量、可维护性和可扩展性。所有参与智能餐饮平台开发的团队和个人必须严格遵守本规范。

## 2. 命名规范

### 2.1 服务命名

| 命名对象 | 规范 | 示例 |
|---------|-----|-----|
| 服务名称 | 使用kebab-case格式，以"yyc3-"为前缀，后跟服务领域名称 | yyc3-user-service, yyc3-menu-service |
| 服务ID | 与服务名称相同，使用小写字母和连字符 | yyc3-user-service |
| Docker镜像名称 | 与服务名称相同，使用小写字母和连字符 | harbor.yyc3.com/yyc3/yyc3-user-service |
| Helm Chart名称 | 与服务名称相同，使用小写字母和连字符 | yyc3-user-service |
| Kubernetes资源名称 | 使用服务名称作为前缀，后跟资源类型缩写 | yyc3-user-service-deployment, yyc3-user-service-service |

### 2.2 代码命名

| 命名对象 | 规范 | 示例 |
|---------|-----|-----|
| 包名 | 使用小写字母，避免使用下划线，采用反转域名命名 | com.yyc3.userservice |
| 类名 | 使用PascalCase，首字母大写 | UserController, MenuService |
| 接口名 | 使用PascalCase，首字母大写，以"I"为前缀 | IUserService, IMenuRepository |
| 方法名 | 使用camelCase，首字母小写，动词开头 | getUserById, createMenu |
| 变量名 | 使用camelCase，首字母小写，有意义的名称 | userId, menuName |
| 常量名 | 使用全大写，单词间用下划线分隔 | MAX_PAGE_SIZE, DEFAULT_TIMEOUT |
| 枚举名 | 使用PascalCase，首字母大写 | OrderStatus, PaymentMethod |
| 注释 | 使用JavaDoc格式，包括@param, @return, @throws等标签 | /**
     * 获取用户信息
     * @param userId 用户ID
     * @return 用户信息
     * @throws UserNotFoundException 用户不存在时抛出
     */ |

### 2.3 数据库命名

| 命名对象 | 规范 | 示例 |
|---------|-----|-----|
| 数据库名 | 服务名称_环境，使用小写字母和下划线 | yyc3_user_service_dev, yyc3_user_service_prod |
| 表名 | 使用小写字母和下划线，采用复数形式 | users, menus, orders |
| 字段名 | 使用小写字母和下划线，避免使用保留字 | user_id, menu_name, order_time |
| 索引名 | 表名_字段名_index，使用小写字母和下划线 | users_email_index, orders_user_id_index |
| 外键名 | 表名_引用表名_字段名_fk，使用小写字母和下划线 | orders_users_user_id_fk |

## 3. 项目结构

### 3.1 标准项目结构

```
├── src/
│   ├── main/
│   │   ├── java/
│   │   │   └── com/
│   │   │       └── yyc3/
│   │   │           └── userservice/          # 服务包名
│   │   │               ├── UserserviceApplication.java  # 应用启动类
│   │   │               ├── config/           # 配置类
│   │   │               ├── controller/       # 控制器层
│   │   │               ├── service/          # 服务层
│   │   │               │   ├── impl/         # 服务实现
│   │   │               ├── repository/       # 数据访问层
│   │   │               ├── entity/           # 实体类
│   │   │               ├── dto/              # 数据传输对象
│   │   │               ├── vo/               # 视图对象
│   │   │               ├── enums/            # 枚举类
│   │   │               ├── exception/        # 自定义异常
│   │   │               ├── interceptor/      # 拦截器
│   │   │               ├── filter/           # 过滤器
│   │   │               ├── handler/          # 全局异常处理器
│   │   │               └── util/             # 工具类
│   │   └── resources/
│   │       ├── application.yml              # 主配置文件
│   │       ├── application-dev.yml          # 开发环境配置
│   │       ├── application-test.yml         # 测试环境配置
│   │       ├── application-staging.yml      # 预发布环境配置
│   │       ├── application-prod.yml         # 生产环境配置
│   │       ├── bootstrap.yml                # 引导配置文件
│   │       ├── mybatis/                     # MyBatis配置
│   │       │   └── mapper/                  # Mapper XML文件
│   │       └── static/                      # 静态资源
│   └── test/
│       ├── java/
│       │   └── com/
│       │       └── yyc3/
│       │           └── userservice/          # 测试包名
│       │               ├── controller/       # 控制器测试
│       │               ├── service/          # 服务测试
│       │               ├── repository/       # 数据访问测试
│       │               └── util/             # 工具类测试
│       └── resources/
│           └── test-data.sql                 # 测试数据
├── pom.xml                                   # Maven配置文件
├── Dockerfile                                # Docker构建文件
├── .gitignore                                # Git忽略文件
├── README.md                                 # 项目说明文档
├── sonar-project.properties                  # SonarQube配置
└── helm/                                     # Helm Chart配置
    ├── Chart.yaml                            # Chart元数据
    ├── values.yaml                           # 默认配置
    ├── values-dev.yaml                       # 开发环境配置
    ├── values-test.yaml                      # 测试环境配置
    ├── values-staging.yaml                   # 预发布环境配置
    ├── values-prod.yaml                      # 生产环境配置
    └── templates/                            # Kubernetes资源模板
        ├── deployment.yaml                   # Deployment模板
        ├── service.yaml                      # Service模板
        ├── ingress.yaml                      # Ingress模板
        ├── hpa.yaml                          # HPA模板
        ├── configmap.yaml                    # ConfigMap模板
        └── secret.yaml                       # Secret模板
```

### 3.2 目录说明

| 目录/文件 | 用途 |
|---------|-----|
| src/main/java | 主源码目录 |
| src/main/resources | 主资源目录 |
| src/test/java | 测试源码目录 |
| src/test/resources | 测试资源目录 |
| config/ | 配置类，包括Spring Boot配置、数据库配置、安全配置等 |
| controller/ | 控制器层，处理HTTP请求和响应 |
| service/ | 服务层，实现业务逻辑 |
| repository/ | 数据访问层，与数据库交互 |
| entity/ | 实体类，映射数据库表结构 |
| dto/ | 数据传输对象，用于服务间通信 |
| vo/ | 视图对象，用于前端展示 |
| enums/ | 枚举类，定义常量集合 |
| exception/ | 自定义异常类 |
| interceptor/ | 拦截器，用于请求拦截和处理 |
| filter/ | 过滤器，用于请求过滤和处理 |
| handler/ | 全局异常处理器，统一处理异常 |
| util/ | 工具类，提供通用功能 |
| application.yml | 主配置文件，定义应用基本配置 |
| application-*.yml | 环境特定配置文件 |
| bootstrap.yml | 引导配置文件，用于加载外部配置 |
| mybatis/mapper/ | MyBatis Mapper XML文件 |
| static/ | 静态资源文件 |
| pom.xml | Maven配置文件，定义依赖和构建配置 |
| Dockerfile | Docker构建文件，用于构建Docker镜像 |
| .gitignore | Git忽略文件，定义不需要纳入版本控制的文件 |
| README.md | 项目说明文档，包括项目介绍、快速入门、API文档等 |
| sonar-project.properties | SonarQube配置文件，用于代码质量分析 |
| helm/ | Helm Chart配置目录，用于Kubernetes部署 |

## 4. 代码风格规范

### 4.1 Java代码风格

1. **缩进**：使用4个空格进行缩进，不使用制表符
2. **行宽**：每行代码不超过120个字符
3. **空行**：
   - 在类、方法、构造函数之间使用空行分隔
   - 在逻辑块之间使用空行分隔
   - 避免连续的空行
4. **空格**：
   - 在二元操作符前后添加空格
   - 在逗号、分号后添加空格
   - 在括号内不添加空格
   - 在控制语句和循环语句的关键字后添加空格
5. **大括号**：
   - 左大括号放在行尾
   - 右大括号放在独立的一行
   - 单行语句也必须使用大括号
6. **注释**：
   - 为所有类、方法、重要变量添加JavaDoc注释
   - 为复杂的业务逻辑添加单行注释
   - 避免不必要的注释

### 4.2 XML代码风格

1. **缩进**：使用2个空格进行缩进
2. **行宽**：每行代码不超过120个字符
3. **标签**：
   - 成对标签必须正确嵌套
   - 单个标签必须自闭合
   - 标签属性使用双引号
4. **注释**：
   - 为复杂的配置添加注释
   - 避免不必要的注释

### 4.3 YAML代码风格

1. **缩进**：使用2个空格进行缩进
2. **键值对**：键和值之间使用冒号加空格分隔
3. **数组**：使用短横线加空格表示数组元素
4. **注释**：使用井号(#)表示注释
5. **引号**：
   - 字符串值一般不需要引号
   - 包含特殊字符的字符串使用双引号

## 5. API设计规范

### 5.1 REST API设计原则

1. **资源导向**：API设计以资源为中心，使用名词而不是动词
2. **统一接口**：使用标准的HTTP方法和状态码
3. **无状态**：API请求必须是无状态的
4. **分层系统**：支持分层架构
5. **缓存**：支持缓存机制
6. **按需编码**：支持按需编码（可选）

### 5.2 HTTP方法使用

| HTTP方法 | 用途 | 示例 |
|---------|-----|-----|
| GET | 获取资源 | GET /api/users 获取用户列表 |
| POST | 创建资源 | POST /api/users 创建用户 |
| PUT | 更新资源（完整更新） | PUT /api/users/1 更新用户信息 |
| PATCH | 更新资源（部分更新） | PATCH /api/users/1 更新用户部分信息 |
| DELETE | 删除资源 | DELETE /api/users/1 删除用户 |

### 5.3 URL设计

1. **使用复数形式**：资源URL使用复数形式
2. **层级结构**：使用斜杠(/)表示资源层级关系
3. **查询参数**：使用问号(?)和&符号表示查询参数
4. **版本控制**：在URL中包含API版本信息

示例：
```
# 获取用户列表
GET /api/v1/users

# 获取特定用户
GET /api/v1/users/1

# 获取用户的订单列表
GET /api/v1/users/1/orders

# 创建用户
POST /api/v1/users

# 更新用户
PUT /api/v1/users/1

# 删除用户
DELETE /api/v1/users/1

# 分页查询用户列表
GET /api/v1/users?page=1&size=10

# 条件查询用户列表
GET /api/v1/users?name=张三&status=active
```

### 5.4 响应格式

1. **统一响应结构**：所有API响应使用统一的结构
2. **状态码**：使用标准的HTTP状态码
3. **错误信息**：错误响应包含详细的错误信息

成功响应示例：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "id": 1,
    "name": "张三",
    "email": "zhangsan@example.com",
    "phone": "13800138000",
    "status": "active",
    "createdAt": "2025-01-30T12:00:00Z",
    "updatedAt": "2025-01-30T12:00:00Z"
  },
  "timestamp": "2025-01-30T12:00:00Z"
}
```

分页响应示例：
```json
{
  "code": 200,
  "message": "操作成功",
  "data": {
    "content": [
      {
        "id": 1,
        "name": "张三",
        "email": "zhangsan@example.com",
        "phone": "13800138000",
        "status": "active",
        "createdAt": "2025-01-30T12:00:00Z",
        "updatedAt": "2025-01-30T12:00:00Z"
      },
      {
        "id": 2,
        "name": "李四",
        "email": "lisi@example.com",
        "phone": "13900139000",
        "status": "active",
        "createdAt": "2025-01-30T12:00:00Z",
        "updatedAt": "2025-01-30T12:00:00Z"
      }
    ],
    "pageable": {
      "pageNumber": 0,
      "pageSize": 10,
      "sort": {
        "sorted": false,
        "unsorted": true,
        "empty": true
      },
      "offset": 0,
      "paged": true,
      "unpaged": false
    },
    "totalPages": 5,
    "totalElements": 45,
    "last": false,
    "size": 10,
    "number": 0,
    "sort": {
      "sorted": false,
      "unsorted": true,
      "empty": true
    },
    "numberOfElements": 10,
    "first": true,
    "empty": false
  },
  "timestamp": "2025-01-30T12:00:00Z"
}
```

错误响应示例：
```json
{
  "code": 404,
  "message": "用户不存在",
  "data": null,
  "timestamp": "2025-01-30T12:00:00Z"
}
```

### 5.5 API版本控制

1. **URL版本控制**：在URL中包含API版本信息，如`/api/v1/users`
2. **版本号格式**：使用v+数字的形式表示版本号，如v1, v2
3. **版本兼容性**：新版本API必须向后兼容旧版本API
4. **版本生命周期**：每个版本API必须有明确的生命周期，包括发布、维护、废弃、删除

## 6. 数据库设计规范

### 6.1 数据库选型

1. **关系型数据库**：使用PostgreSQL作为主要关系型数据库
2. **非关系型数据库**：使用Redis作为缓存和消息队列
3. **搜索引擎**：使用Elasticsearch作为搜索引擎

### 6.2 表设计原则

1. **范式**：遵循第三范式(3NF)，避免数据冗余
2. **主键**：
   - 所有表必须有主键
   - 主键使用自增整数或UUID
   - 避免使用复合主键
3. **外键**：
   - 使用外键建立表之间的关系
   - 外键必须引用其他表的主键
   - 外键必须有适当的级联操作
4. **字段**：
   - 为每个字段选择合适的数据类型
   - 为非空字段添加NOT NULL约束
   - 为重要字段添加索引
   - 为字符串字段设置合适的长度
5. **时间字段**：
   - 使用created_at字段记录创建时间
   - 使用updated_at字段记录更新时间
   - 时间字段使用TIMESTAMP WITH TIME ZONE类型

### 6.3 索引设计原则

1. **唯一性索引**：为唯一约束的字段添加唯一性索引
2. **查询索引**：为经常用于查询条件的字段添加索引
3. **连接索引**：为经常用于表连接的字段添加索引
4. **复合索引**：为经常一起使用的多个字段添加复合索引
5. **索引数量**：避免过多的索引，每个表的索引数量不超过10个
6. **索引维护**：定期检查和优化索引

### 6.4 存储过程和触发器

1. **避免使用存储过程**：业务逻辑应该在应用层实现，而不是在数据库层
2. **谨慎使用触发器**：只有在必要的情况下使用触发器，如审计日志
3. **存储过程命名**：如果必须使用存储过程，使用sp_前缀，后跟存储过程名称
4. **触发器命名**：如果必须使用触发器，使用tr_前缀，后跟触发器名称

## 7. 错误处理和日志规范

### 7.1 错误处理

1. **自定义异常**：
   - 为所有业务异常创建自定义异常类
   - 自定义异常必须继承自RuntimeException
   - 自定义异常必须包含错误代码和错误消息
2. **全局异常处理器**：
   - 使用@RestControllerAdvice注解创建全局异常处理器
   - 为所有异常类型添加处理方法
   - 返回统一的错误响应格式
3. **错误代码**：
   - 使用4位数字表示错误代码
   - 错误代码分为不同的区间，代表不同的错误类型
   - 错误代码必须有明确的文档说明

错误代码示例：

| 错误代码区间 | 错误类型 |
|---------|-----|
| 1000-1999 | 系统错误 |
| 2000-2999 | 用户相关错误 |
| 3000-3999 | 菜单相关错误 |
| 4000-4999 | 订单相关错误 |
| 5000-5999 | 支付相关错误 |
| 6000-6999 | 餐厅相关错误 |
| 7000-7999 | 营销相关错误 |
| 8000-8999 | 通知相关错误 |
| 9000-9999 | 报表相关错误 |

### 7.2 日志规范

1. **日志框架**：使用SLF4J + Logback作为日志框架
2. **日志级别**：
   - TRACE：最详细的日志，用于调试
   - DEBUG：调试信息，用于开发环境
   - INFO：普通信息，用于生产环境
   - WARN：警告信息，用于潜在问题
   - ERROR：错误信息，用于发生错误的情况
3. **日志格式**：
   - 包含时间戳、日志级别、线程名、类名、方法名、行号、日志消息
   - 日志消息使用JSON格式，便于日志分析工具处理
4. **日志内容**：
   - 记录所有重要的业务操作
   - 记录所有异常信息，包括异常类型、异常消息、堆栈跟踪
   - 记录所有外部API调用，包括请求参数和响应结果
   - 避免记录敏感信息，如密码、API密钥等

日志配置示例（logback-spring.xml）：

```xml
<configuration>
    <springProperty scope="context" name="applicationName" source="spring.application.name"/>
    <springProperty scope="context" name="logLevel" source="logging.level.root" defaultValue="INFO"/>
    
    <appender name="CONSOLE" class="ch.qos.logback.core.ConsoleAppender">
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}.%M:%L - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>
    
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/${applicationName}.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/${applicationName}.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>10GB</totalSizeCap>
        </rollingPolicy>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss.SSS} [%thread] %-5level %logger{36}.%M:%L - %msg%n</pattern>
            <charset>UTF-8</charset>
        </encoder>
    </appender>
    
    <appender name="JSON_FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/${applicationName}-json.log</file>
        <rollingPolicy class="ch.qos.logback.core.rolling.SizeAndTimeBasedRollingPolicy">
            <fileNamePattern>logs/${applicationName}-json.%d{yyyy-MM-dd}.%i.log</fileNamePattern>
            <maxFileSize>100MB</maxFileSize>
            <maxHistory>30</maxHistory>
            <totalSizeCap>10GB</totalSizeCap>
        </rollingPolicy>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder">
            <customFields>{"application":"${applicationName}","environment":"${spring.profiles.active}"}</customFields>
        </encoder>
    </appender>
    
    <root level="${logLevel}">
        <appender-ref ref="CONSOLE"/>
        <appender-ref ref="FILE"/>
        <appender-ref ref="JSON_FILE"/>
    </root>
    
    <!-- 第三方库日志级别 -->
    <logger name="org.springframework" level="INFO"/>
    <logger name="org.apache" level="INFO"/>
    <logger name="com.fasterxml" level="INFO"/>
    <logger name="io.netty" level="INFO"/>
    <logger name="io.grpc" level="INFO"/>
    <logger name="org.mybatis" level="INFO"/>
    <logger name="com.zaxxer" level="INFO"/>
    <logger name="redis.clients" level="INFO"/>
</configuration>
```

## 8. 测试规范

### 8.1 测试类型

1. **单元测试**：
   - 测试单个类或方法的功能
   - 使用JUnit和Mockito进行单元测试
   - 单元测试覆盖率要求≥80%
2. **集成测试**：
   - 测试多个类或模块的集成功能
   - 使用JUnit和Testcontainers进行集成测试
   - 集成测试覆盖率要求≥60%
3. **端到端测试**：
   - 测试完整的业务流程
   - 使用Selenium或Postman进行端到端测试
   - 端到端测试覆盖率要求≥40%
4. **性能测试**：
   - 测试系统的性能和稳定性
   - 使用JMeter进行性能测试
   - 性能测试必须满足系统性能要求
5. **安全测试**：
   - 测试系统的安全性
   - 使用OWASP ZAP或Burp Suite进行安全测试
   - 安全测试必须满足系统安全要求

### 8.2 测试命名规范

| 测试类型 | 命名规范 | 示例 |
|---------|-----|-----|
| 单元测试 | 类名+Test，方法名+Test | UserServiceTest, getUserByIdTest |
| 集成测试 | 类名+IntegrationTest，方法名+IntegrationTest | UserServiceIntegrationTest, createUserIntegrationTest |
| 端到端测试 | 类名+E2ETest，方法名+E2ETest | UserControllerE2ETest, loginE2ETest |
| 性能测试 | 类名+PerformanceTest，方法名+PerformanceTest | UserServicePerformanceTest, getUserByIdPerformanceTest |
| 安全测试 | 类名+SecurityTest，方法名+SecurityTest | UserControllerSecurityTest, loginSecurityTest |

### 8.3 测试数据管理

1. **测试数据隔离**：测试数据必须与生产数据隔离
2. **测试数据准备**：
   - 使用Testcontainers创建临时数据库
   - 使用@Sql注解加载测试数据
   - 使用测试数据生成工具生成测试数据
3. **测试数据清理**：
   - 每个测试方法执行后清理测试数据
   - 使用@AfterEach注解清理测试数据
   - 使用事务回滚清理测试数据

## 9. 安全规范

### 9.1 认证和授权

1. **认证**：
   - 使用OAuth 2.0和JWT进行认证
   - 认证服务器使用Keycloak
   - 所有API必须进行认证
2. **授权**：
   - 使用RBAC（基于角色的访问控制）进行授权
   - 为每个API端点定义访问权限
   - 使用@PreAuthorize注解进行权限控制
3. **密码管理**：
   - 密码必须使用BCrypt或Argon2进行哈希
   - 密码长度必须至少为8个字符
   - 密码必须包含大小写字母、数字和特殊字符
   - 密码必须定期更换

### 9.2 数据安全

1. **数据加密**：
   - 敏感数据必须在传输和存储时进行加密
   - 传输加密使用TLS 1.3
   - 存储加密使用AES-256
2. **数据脱敏**：
   - 敏感数据在日志和API响应中必须脱敏
   - 脱敏规则必须明确和一致
3. **数据访问控制**：
   - 实现最小权限原则，用户只能访问必要的数据
   - 数据访问必须经过认证和授权
   - 数据访问必须记录审计日志

### 9.3 API安全

1. **API密钥**：
   - 为外部API调用使用API密钥
   - API密钥必须定期更换
   - API密钥必须使用加密存储
2. **请求限制**：
   - 为API端点设置请求限制
   - 使用RateLimiter限制请求频率
   - 防止DDoS攻击
3. **输入验证**：
   - 对所有API输入进行验证
   - 使用@Valid和@NotBlank等注解进行验证
   - 防止SQL注入、XSS攻击等
4. **输出编码**：
   - 对所有API输出进行编码
   - 防止XSS攻击等

## 10. 部署和监控规范

### 10.1 部署规范

1. **容器化**：
   - 所有微服务必须使用Docker容器化
   - Docker镜像必须符合最佳实践
   - Docker镜像必须存储在Harbor镜像仓库
2. **编排**：
   - 使用Kubernetes进行容器编排
   - 使用Helm进行应用打包和部署
   - 部署配置必须包含资源限制和健康检查
3. **环境**：
   - 使用不同的环境（开发、测试、预发布、生产）
   - 环境之间必须隔离
   - 环境配置必须使用配置中心管理

### 10.2 监控规范

1. **监控指标**：
   - 监控应用指标（请求数、响应时间、错误率等）
   - 监控系统指标（CPU、内存、磁盘、网络等）
   - 监控业务指标（订单量、交易额、用户活跃度等）
2. **监控工具**：
   - 使用Prometheus进行指标收集
   - 使用Grafana进行指标可视化
   - 使用Alertmanager进行告警管理
3. **告警规则**：
   - 定义明确的告警规则
   - 告警规则必须包含阈值、持续时间和严重程度
   - 告警必须及时通知相关人员

## 11. 代码模板

### 11.1 Spring Boot应用启动类模板

```java
/**
 * @file UserServiceApplication.java
 * @description 用户服务应用启动类
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.client.discovery.EnableDiscoveryClient;
import org.springframework.cloud.openfeign.EnableFeignClients;

/**
 * 用户服务应用启动类
 */
@SpringBootApplication
@EnableDiscoveryClient
@EnableFeignClients
public class UserServiceApplication {

    /**
     * 主方法
     * @param args 命令行参数
     */
    public static void main(String[] args) {
        SpringApplication.run(UserServiceApplication.class, args);
    }

}
```

### 11.2 控制器模板

```java
/**
 * @file UserController.java
 * @description 用户控制器
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.controller;

import com.yyc3.userservice.dto.UserDTO;
import com.yyc3.userservice.dto.UserQueryDTO;
import com.yyc3.userservice.service.UserService;
import com.yyc3.userservice.vo.UserVO;
import com.yyc3.userservice.vo.PageVO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.validation.annotation.Validated;
import org.springframework.web.bind.annotation.*;

/**
 * 用户控制器
 */
@RestController
@RequestMapping("/api/v1/users")
@Tag(name = "用户管理", description = "用户相关API")
public class UserController {

    @Autowired
    private UserService userService;

    /**
     * 获取用户列表
     * @param queryDTO 查询参数
     * @return 用户列表
     */
    @GetMapping
    @Operation(summary = "获取用户列表", description = "获取所有用户的列表")
    @PreAuthorize("hasAuthority('user:list')")
    public ResponseEntity<PageVO<UserVO>> getUserList(@Validated UserQueryDTO queryDTO) {
        PageVO<UserVO> pageVO = userService.getUserList(queryDTO);
        return ResponseEntity.ok(pageVO);
    }

    /**
     * 获取用户详情
     * @param id 用户ID
     * @return 用户详情
     */
    @GetMapping("/{id}")
    @Operation(summary = "获取用户详情", description = "根据ID获取用户的详细信息")
    @PreAuthorize("hasAuthority('user:detail')")
    public ResponseEntity<UserVO> getUserById(@PathVariable @Parameter(description = "用户ID") Long id) {
        UserVO userVO = userService.getUserById(id);
        return ResponseEntity.ok(userVO);
    }

    /**
     * 创建用户
     * @param userDTO 用户信息
     * @return 创建的用户
     */
    @PostMapping
    @Operation(summary = "创建用户", description = "创建新用户")
    @PreAuthorize("hasAuthority('user:create')")
    public ResponseEntity<UserVO> createUser(@Validated @RequestBody UserDTO userDTO) {
        UserVO userVO = userService.createUser(userDTO);
        return ResponseEntity.status(HttpStatus.CREATED).body(userVO);
    }

    /**
     * 更新用户
     * @param id 用户ID
     * @param userDTO 用户信息
     * @return 更新后的用户
     */
    @PutMapping("/{id}")
    @Operation(summary = "更新用户", description = "根据ID更新用户信息")
    @PreAuthorize("hasAuthority('user:update')")
    public ResponseEntity<UserVO> updateUser(@PathVariable @Parameter(description = "用户ID") Long id, @Validated @RequestBody UserDTO userDTO) {
        UserVO userVO = userService.updateUser(id, userDTO);
        return ResponseEntity.ok(userVO);
    }

    /**
     * 删除用户
     * @param id 用户ID
     * @return 无
     */
    @DeleteMapping("/{id}")
    @Operation(summary = "删除用户", description = "根据ID删除用户")
    @PreAuthorize("hasAuthority('user:delete')")
    public ResponseEntity<Void> deleteUser(@PathVariable @Parameter(description = "用户ID") Long id) {
        userService.deleteUser(id);
        return ResponseEntity.noContent().build();
    }
}
```

### 11.3 服务接口模板

```java
/**
 * @file IUserService.java
 * @description 用户服务接口
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.service;

import com.yyc3.userservice.dto.UserDTO;
import com.yyc3.userservice.dto.UserQueryDTO;
import com.yyc3.userservice.vo.UserVO;
import com.yyc3.userservice.vo.PageVO;

/**
 * 用户服务接口
 */
public interface IUserService {

    /**
     * 获取用户列表
     * @param queryDTO 查询参数
     * @return 用户列表
     */
    PageVO<UserVO> getUserList(UserQueryDTO queryDTO);

    /**
     * 获取用户详情
     * @param id 用户ID
     * @return 用户详情
     */
    UserVO getUserById(Long id);

    /**
     * 创建用户
     * @param userDTO 用户信息
     * @return 创建的用户
     */
    UserVO createUser(UserDTO userDTO);

    /**
     * 更新用户
     * @param id 用户ID
     * @param userDTO 用户信息
     * @return 更新后的用户
     */
    UserVO updateUser(Long id, UserDTO userDTO);

    /**
     * 删除用户
     * @param id 用户ID
     */
    void deleteUser(Long id);
}
```

### 11.4 服务实现模板

```java
/**
 * @file UserServiceImpl.java
 * @description 用户服务实现类
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.service.impl;

import com.yyc3.userservice.dto.UserDTO;
import com.yyc3.userservice.dto.UserQueryDTO;
import com.yyc3.userservice.entity.User;
import com.yyc3.userservice.exception.UserNotFoundException;
import com.yyc3.userservice.repository.UserRepository;
import com.yyc3.userservice.service.IUserService;
import com.yyc3.userservice.vo.UserVO;
import com.yyc3.userservice.vo.PageVO;
import org.modelmapper.ModelMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;

/**
 * 用户服务实现类
 */
@Service
@Transactional(rollbackFor = Exception.class)
public class UserServiceImpl implements IUserService {

    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private ModelMapper modelMapper;

    /**
     * 获取用户列表
     * @param queryDTO 查询参数
     * @return 用户列表
     */
    @Override
    @Transactional(readOnly = true)
    public PageVO<UserVO> getUserList(UserQueryDTO queryDTO) {
        logger.info("获取用户列表，查询参数：{}", queryDTO);
        
        // 构建分页参数
        Pageable pageable = PageRequest.of(
                queryDTO.getPage() - 1, 
                queryDTO.getSize(), 
                Sort.by(Sort.Direction.DESC, "createdAt")
        );
        
        // 构建查询条件
        // 这里可以根据queryDTO构建动态查询条件
        
        // 执行查询
        Page<User> userPage = userRepository.findAll(pageable);
        
        // 转换为VO
        Page<UserVO> userVOPage = userPage.map(user -> modelMapper.map(user, UserVO.class));
        
        // 转换为PageVO
        PageVO<UserVO> pageVO = new PageVO<>();
        pageVO.setContent(userVOPage.getContent());
        pageVO.setTotalPages(userVOPage.getTotalPages());
        pageVO.setTotalElements(userVOPage.getTotalElements());
        pageVO.setSize(userVOPage.getSize());
        pageVO.setNumber(userVOPage.getNumber() + 1);
        pageVO.setFirst(userVOPage.isFirst());
        pageVO.setLast(userVOPage.isLast());
        pageVO.setNumberOfElements(userVOPage.getNumberOfElements());
        
        logger.info("获取用户列表成功，共{}页{}条记录", pageVO.getTotalPages(), pageVO.getTotalElements());
        return pageVO;
    }

    /**
     * 获取用户详情
     * @param id 用户ID
     * @return 用户详情
     */
    @Override
    @Transactional(readOnly = true)
    public UserVO getUserById(Long id) {
        logger.info("获取用户详情，用户ID：{}", id);
        
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("用户不存在，用户ID：" + id));
        
        UserVO userVO = modelMapper.map(user, UserVO.class);
        
        logger.info("获取用户详情成功，用户ID：{}", id);
        return userVO;
    }

    /**
     * 创建用户
     * @param userDTO 用户信息
     * @return 创建的用户
     */
    @Override
    public UserVO createUser(UserDTO userDTO) {
        logger.info("创建用户，用户信息：{}", userDTO);
        
        // 检查用户是否已存在
        boolean exists = userRepository.existsByEmail(userDTO.getEmail());
        if (exists) {
            throw new IllegalArgumentException("邮箱已被注册：" + userDTO.getEmail());
        }
        
        // 转换为实体
        User user = modelMapper.map(userDTO, User.class);
        
        // 设置默认值
        user.setStatus("active");
        
        // 保存用户
        user = userRepository.save(user);
        
        // 转换为VO
        UserVO userVO = modelMapper.map(user, UserVO.class);
        
        logger.info("创建用户成功，用户ID：{}", user.getId());
        return userVO;
    }

    /**
     * 更新用户
     * @param id 用户ID
     * @param userDTO 用户信息
     * @return 更新后的用户
     */
    @Override
    public UserVO updateUser(Long id, UserDTO userDTO) {
        logger.info("更新用户，用户ID：{}，用户信息：{}", id, userDTO);
        
        // 获取用户
        User user = userRepository.findById(id)
                .orElseThrow(() -> new UserNotFoundException("用户不存在，用户ID：" + id));
        
        // 检查邮箱是否已被其他用户使用
        if (!user.getEmail().equals(userDTO.getEmail())) {
            boolean exists = userRepository.existsByEmail(userDTO.getEmail());
            if (exists) {
                throw new IllegalArgumentException("邮箱已被注册：" + userDTO.getEmail());
            }
        }
        
        // 更新用户信息
        modelMapper.map(userDTO, user);
        
        // 保存用户
        user = userRepository.save(user);
        
        // 转换为VO
        UserVO userVO = modelMapper.map(user, UserVO.class);
        
        logger.info("更新用户成功，用户ID：{}", id);
        return userVO;
    }

    /**
     * 删除用户
     * @param id 用户ID
     */
    @Override
    public void deleteUser(Long id) {
        logger.info("删除用户，用户ID：{}", id);
        
        // 检查用户是否存在
        boolean exists = userRepository.existsById(id);
        if (!exists) {
            throw new UserNotFoundException("用户不存在，用户ID：" + id);
        }
        
        // 删除用户
        userRepository.deleteById(id);
        
        logger.info("删除用户成功，用户ID：{}", id);
    }
}
```

### 11.5 数据传输对象模板

```java
/**
 * @file UserDTO.java
 * @description 用户数据传输对象
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.dto;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import javax.validation.constraints.Email;
import javax.validation.constraints.NotBlank;
import javax.validation.constraints.Size;

/**
 * 用户数据传输对象
 */
@Data
@Schema(description = "用户数据传输对象")
public class UserDTO {

    @Schema(description = "用户名")
    @NotBlank(message = "用户名不能为空")
    @Size(min = 2, max = 50, message = "用户名长度必须在2到50个字符之间")
    private String name;

    @Schema(description = "邮箱")
    @NotBlank(message = "邮箱不能为空")
    @Email(message = "邮箱格式不正确")
    @Size(max = 100, message = "邮箱长度不能超过100个字符")
    private String email;

    @Schema(description = "手机号")
    @NotBlank(message = "手机号不能为空")
    @Size(min = 11, max = 11, message = "手机号长度必须为11个字符")
    private String phone;

    @Schema(description = "密码")
    @NotBlank(message = "密码不能为空")
    @Size(min = 8, max = 50, message = "密码长度必须在8到50个字符之间")
    private String password;

    @Schema(description = "状态")
    private String status;

    @Schema(description = "角色ID")
    private Long roleId;
}
```

### 11.6 视图对象模板

```java
/**
 * @file UserVO.java
 * @description 用户视图对象
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * 用户视图对象
 */
@Data
@Schema(description = "用户视图对象")
public class UserVO {

    @Schema(description = "用户ID")
    private Long id;

    @Schema(description = "用户名")
    private String name;

    @Schema(description = "邮箱")
    private String email;

    @Schema(description = "手机号")
    private String phone;

    @Schema(description = "状态")
    private String status;

    @Schema(description = "角色ID")
    private Long roleId;

    @Schema(description = "角色名称")
    private String roleName;

    @Schema(description = "创建时间")
    private LocalDateTime createdAt;

    @Schema(description = "更新时间")
    private LocalDateTime updatedAt;
}
```

### 11.7 实体类模板

```java
/**
 * @file User.java
 * @description 用户实体类
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.entity;

import lombok.Data;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;
import javax.persistence.*;
import java.time.LocalDateTime;

/**
 * 用户实体类
 */
@Data
@Entity
@Table(name = "users")
@EntityListeners(AuditingEntityListener.class)
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(name = "name", nullable = false, length = 50)
    private String name;

    @Column(name = "email", nullable = false, length = 100, unique = true)
    private String email;

    @Column(name = "phone", nullable = false, length = 11, unique = true)
    private String phone;

    @Column(name = "password", nullable = false, length = 100)
    private String password;

    @Column(name = "status", nullable = false, length = 20)
    private String status;

    @Column(name = "role_id", nullable = false)
    private Long roleId;

    @CreatedDate
    @Column(name = "created_at", nullable = false, updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at", nullable = false)
    private LocalDateTime updatedAt;
}
```

### 11.8 自定义异常模板

```java
/**
 * @file UserNotFoundException.java
 * @description 用户未找到异常
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.exception;

/**
 * 用户未找到异常
 */
public class UserNotFoundException extends RuntimeException {

    /**
     * 构造函数
     * @param message 异常消息
     */
    public UserNotFoundException(String message) {
        super(message);
    }

    /**
     * 构造函数
     * @param message 异常消息
     * @param cause 异常原因
     */
    public UserNotFoundException(String message, Throwable cause) {
        super(message, cause);
    }
}
```

### 11.9 全局异常处理器模板

```java
/**
 * @file GlobalExceptionHandler.java
 * @description 全局异常处理器
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.handler;

import com.yyc3.userservice.exception.UserNotFoundException;
import com.yyc3.userservice.vo.ResponseVO;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.validation.FieldError;
import org.springframework.web.bind.MethodArgumentNotValidException;
import org.springframework.web.bind.annotation.ExceptionHandler;
import org.springframework.web.bind.annotation.RestControllerAdvice;
import org.springframework.web.context.request.WebRequest;

import java.time.LocalDateTime;
import java.util.HashMap;
import java.util.Map;

/**
 * 全局异常处理器
 */
@RestControllerAdvice
public class GlobalExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);

    /**
     * 处理用户未找到异常
     * @param ex 用户未找到异常
     * @param request 请求
     * @return 响应
     */
    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<ResponseVO<Void>> handleUserNotFoundException(UserNotFoundException ex, WebRequest request) {
        logger.error("用户未找到异常：{}", ex.getMessage());
        
        ResponseVO<Void> responseVO = new ResponseVO<>();
        responseVO.setCode(HttpStatus.NOT_FOUND.value());
        responseVO.setMessage(ex.getMessage());
        responseVO.setTimestamp(LocalDateTime.now());
        
        return ResponseEntity.status(HttpStatus.NOT_FOUND).body(responseVO);
    }

    /**
     * 处理参数验证异常
     * @param ex 参数验证异常
     * @param request 请求
     * @return 响应
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public ResponseEntity<ResponseVO<Map<String, String>>> handleMethodArgumentNotValidException(MethodArgumentNotValidException ex, WebRequest request) {
        logger.error("参数验证异常：{}", ex.getMessage());
        
        Map<String, String> errors = new HashMap<>();
        ex.getBindingResult().getAllErrors().forEach((error) -> {
            String fieldName = ((FieldError) error).getField();
            String errorMessage = error.getDefaultMessage();
            errors.put(fieldName, errorMessage);
        });
        
        ResponseVO<Map<String, String>> responseVO = new ResponseVO<>();
        responseVO.setCode(HttpStatus.BAD_REQUEST.value());
        responseVO.setMessage("参数验证失败");
        responseVO.setData(errors);
        responseVO.setTimestamp(LocalDateTime.now());
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVO);
    }

    /**
     * 处理非法参数异常
     * @param ex 非法参数异常
     * @param request 请求
     * @return 响应
     */
    @ExceptionHandler(IllegalArgumentException.class)
    public ResponseEntity<ResponseVO<Void>> handleIllegalArgumentException(IllegalArgumentException ex, WebRequest request) {
        logger.error("非法参数异常：{}", ex.getMessage());
        
        ResponseVO<Void> responseVO = new ResponseVO<>();
        responseVO.setCode(HttpStatus.BAD_REQUEST.value());
        responseVO.setMessage(ex.getMessage());
        responseVO.setTimestamp(LocalDateTime.now());
        
        return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(responseVO);
    }

    /**
     * 处理所有其他异常
     * @param ex 异常
     * @param request 请求
     * @return 响应
     */
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ResponseVO<Void>> handleAllExceptions(Exception ex, WebRequest request) {
        logger.error("系统异常：{}", ex.getMessage(), ex);
        
        ResponseVO<Void> responseVO = new ResponseVO<>();
        responseVO.setCode(HttpStatus.INTERNAL_SERVER_ERROR.value());
        responseVO.setMessage("系统内部错误，请联系管理员");
        responseVO.setTimestamp(LocalDateTime.now());
        
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(responseVO);
    }
}
```

### 11.10 响应对象模板

```java
/**
 * @file ResponseVO.java
 * @description 统一响应对象
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import java.time.LocalDateTime;

/**
 * 统一响应对象
 * @param <T> 响应数据类型
 */
@Data
@Schema(description = "统一响应对象")
public class ResponseVO<T> {

    @Schema(description = "响应代码")
    private Integer code;

    @Schema(description = "响应消息")
    private String message;

    @Schema(description = "响应数据")
    private T data;

    @Schema(description = "响应时间")
    private LocalDateTime timestamp;
}
```

### 11.11 分页对象模板

```java
/**
 * @file PageVO.java
 * @description 分页对象
 * @author YYC³团队
 * @version 1.0.0
 */
package com.yyc3.userservice.vo;

import io.swagger.v3.oas.annotations.media.Schema;
import lombok.Data;
import java.util.List;

/**
 * 分页对象
 * @param <T> 数据类型
 */
@Data
@Schema(description = "分页对象")
public class PageVO<T> {

    @Schema(description = "数据列表")
    private List<T> content;

    @Schema(description = "总页数")
    private int totalPages;

    @Schema(description = "总记录数")
    private long totalElements;

    @Schema(description = "每页记录数")
    private int size;

    @Schema(description = "当前页码")
    private int number;

    @Schema(description = "是否为第一页")
    private boolean first;

    @Schema(description = "是否为最后一页")
    private boolean last;

    @Schema(description = "当前页记录数")
    private int numberOfElements;
}
```

## 12. 文档和注释规范

### 12.1 项目文档

1. **README.md**：
   - 项目介绍
   - 快速入门
   - API文档
   - 部署指南
   - 贡献指南
   - 许可证
2. **API文档**：
   - 使用Swagger生成API文档
   - API文档必须包含所有API端点的详细信息
   - API文档必须包含请求参数、响应格式、错误代码等信息
3. **架构文档**：
   - 系统架构图
   - 服务间关系图
   - 数据流图
   - 部署架构图
4. **数据库文档**：
   - 数据库表结构
   - 表之间的关系
   - 索引设计
   - 存储过程和触发器

### 12.2 代码注释

1. **类注释**：
   - 为所有类添加JavaDoc注释
   - 类注释必须包含@file, @description, @author, @version等标签
2. **方法注释**：
   - 为所有方法添加JavaDoc注释
   - 方法注释必须包含@param, @return, @throws等标签
3. **字段注释**：
   - 为所有重要字段添加JavaDoc注释
   - 字段注释必须包含@description等标签
4. **业务逻辑注释**：
   - 为复杂的业务逻辑添加单行注释
   - 单行注释使用//开头
   - 注释必须清晰、简洁、准确

## 13. 版本管理和发布规范

### 13.1 版本号格式

使用语义化版本号（Semantic Versioning）：

```
MAJOR.MINOR.PATCH
```

- **MAJOR**：不兼容的API变更
- **MINOR**：向下兼容的功能性新增
- **PATCH**：向下兼容的问题修正

### 13.2 版本发布流程

1. **开发**：在develop分支进行开发
2. **测试**：开发完成后，合并到test分支进行测试
3. **预发布**：测试通过后，合并到staging分支进行预发布验证
4. **发布**：预发布验证通过后，合并到main分支并打标签
5. **部署**：使用CI/CD流水线自动部署到生产环境

### 13.3 版本发布通知

1. **发布前通知**：发布前必须通知相关团队和用户
2. **发布后通知**：发布后必须通知相关团队和用户
3. **版本日志**：每个版本必须有详细的版本日志，包括：
   - 新增功能
   - 修复的问题
   - 变更的API
   - 已知问题

## 12. Node.js/Express 技术栈实现模板

### 12.1 应用启动类模板

```typescript
/**
 * @file app.ts
 * @description 应用启动类
 * @author YYC³团队
 * @version 1.0.0
 */

import express, { Express } from 'express';
import helmet from 'helmet';
import cors from 'cors';
import { json, urlencoded } from 'body-parser';
import { config } from './config';
import { logger } from './utils/logger';
import { sequelize, testDatabaseConnection, syncDatabase } from './config/database';
import { userRoutes } from './routes/userRoutes';
import { errorHandler } from './middleware/errorHandler';
import { requestLogger } from './middleware/requestLogger';

/**
 * 创建Express应用
 */
const createApp = (): Express => {
  const app: Express = express();

  // 配置安全中间件
  app.use(helmet({
    contentSecurityPolicy: config.cors.enabled ? undefined : helmet.contentSecurityPolicy.getDefaultDirectives(),
    crossOriginEmbedderPolicy: config.cors.enabled ? undefined : true,
    crossOriginResourcePolicy: config.cors.enabled ? { policy: 'cross-origin' } : undefined
  }));

  // 配置CORS
  const corsOptions = config.cors.enabled ? {
    origin: config.cors.origins,
    credentials: config.cors.credentials,
    methods: config.cors.methods,
    allowedHeaders: config.cors.headers
  } : {};

  app.use(cors(corsOptions));

  // 配置请求体解析
  app.use(json({
    limit: config.request.bodyLimit
  }));
  app.use(urlencoded({
    extended: true,
    limit: config.request.bodyLimit
  }));

  // 配置请求日志中间件
  app.use(requestLogger);

  // 健康检查路由
  app.get('/health', (req, res) => {
    res.status(200).json({
      status: 'ok',
      timestamp: new Date().toISOString(),
      service: config.service.name,
      environment: config.service.environment,
      version: config.service.version
    });
  });

  // 注册API路由
  app.use('/api/v1/users', userRoutes);

  // 配置错误处理中间件
  app.use(errorHandler);

  return app;
};

/**
 * 启动应用
 */
const startApp = async () => {
  try {
    // 测试数据库连接
    await testDatabaseConnection();
    
    // 同步数据库模型
    await syncDatabase();
    
    // 创建应用
    const app = createApp();

    // 启动服务器
    const server = app.listen(config.server.port, config.server.host, () => {
      logger.info(
        `🚀 ${config.service.name} v${config.service.version} 已启动`,
        {
          host: config.server.host,
          port: config.server.port,
          environment: config.service.environment,
          pid: process.pid
        }
      );
    });

    // 优雅关闭处理
    const handleShutdown = async () => {
      logger.info('正在关闭服务器...');
      
      // 关闭数据库连接
      await sequelize.close();
      
      // 关闭服务器
      server.close((err) => {
        if (err) {
          logger.error('服务器关闭失败', err);
          process.exit(1);
        }
        logger.info('服务器已成功关闭');
        process.exit(0);
      });
    };

    // 监听关闭信号
    process.on('SIGINT', handleShutdown);
    process.on('SIGTERM', handleShutdown);

  } catch (error) {
    logger.error('应用启动失败', error);
    process.exit(1);
  }
};

// 启动应用
if (require.main === module) {
  startApp();
}

export { createApp, startApp };
```

### 12.2 控制器模板

```typescript
/**
 * @file userController.ts
 * @description 用户控制器
 * @author YYC³团队
 * @version 1.0.0
 */

import { Request, Response, NextFunction } from 'express';
import { UserService } from '../services/userService';
import { logger } from '../utils/logger';
import { CreateUserDto, UpdateUserDto, UserDto } from '../dtos/userDto';

/**
 * 用户控制器类
 */
export class UserController {
  private userService: UserService;

  constructor() {
    this.userService = new UserService();
  }

  /**
   * 获取用户列表
   * @param req 请求对象
   * @param res 响应对象
   * @param next 中间件函数
   */
  public getUsers = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { page = 1, limit = 10 } = req.query;
      const users = await this.userService.getUsers({
        page: Number(page),
        limit: Number(limit)
      });

      res.status(200).json(users);
    } catch (error) {
      logger.error('获取用户列表失败', error);
      next(error);
    }
  };

  /**
   * 获取用户详情
   * @param req 请求对象
   * @param res 响应对象
   * @param next 中间件函数
   */
  public getUserById = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      const user = await this.userService.getUserById(id);

      res.status(200).json(user);
    } catch (error) {
      logger.error(`获取用户详情失败，用户ID: ${req.params.id}`, error);
      next(error);
    }
  };

  /**
   * 创建用户
   * @param req 请求对象
   * @param res 响应对象
   * @param next 中间件函数
   */
  public createUser = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const userData: CreateUserDto = req.body;
      const user = await this.userService.createUser(userData);

      res.status(201).json(user);
    } catch (error) {
      logger.error('创建用户失败', error);
      next(error);
    }
  };

  /**
   * 更新用户
   * @param req 请求对象
   * @param res 响应对象
   * @param next 中间件函数
   */
  public updateUser = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      const userData: UpdateUserDto = req.body;
      const user = await this.userService.updateUser(id, userData);

      res.status(200).json(user);
    } catch (error) {
      logger.error(`更新用户失败，用户ID: ${req.params.id}`, error);
      next(error);
    }
  };

  /**
   * 删除用户
   * @param req 请求对象
   * @param res 响应对象
   * @param next 中间件函数
   */
  public deleteUser = async (req: Request, res: Response, next: NextFunction): Promise<void> => {
    try {
      const { id } = req.params;
      await this.userService.deleteUser(id);

      res.status(204).send();
    } catch (error) {
      logger.error(`删除用户失败，用户ID: ${req.params.id}`, error);
      next(error);
    }
  };
}
```

### 12.3 服务模板

```typescript
/**
 * @file userService.ts
 * @description 用户服务
 * @author YYC³团队
 * @version 1.0.0
 */

import { UserRepository } from '../repositories/userRepository';
import { CreateUserDto, UpdateUserDto, UserDto, UserResponse } from '../dtos/userDto';
import { User } from '../models/user';
import { NotFoundError } from '../errors/NotFoundError';
import { BadRequestError } from '../errors/BadRequestError';
import { hashPassword } from '../utils/passwordUtils';
import { PaginationOptions, PaginationResult } from '../types/pagination';
import { logger } from '../utils/logger';

/**
 * 用户服务类
 */
export class UserService {
  private userRepository: UserRepository;

  constructor() {
    this.userRepository = new UserRepository();
  }

  /**
   * 获取用户列表
   * @param options 分页选项
   * @returns 用户列表
   */
  public async getUsers(options: PaginationOptions): Promise<PaginationResult<UserDto>> {
    const { page, limit } = options;
    const offset = (page - 1) * limit;

    const [users, total] = await Promise.all([
      this.userRepository.findAll(limit, offset),
      this.userRepository.count()
    ]);

    const userDtos = users.map((user) => this.mapToDto(user));

    return {
      data: userDtos,
      pagination: {
        page,
        limit,
        total,
        totalPages: Math.ceil(total / limit)
      }
    };
  }

  /**
   * 获取用户详情
   * @param id 用户ID
   * @returns 用户详情
   */
  public async getUserById(id: string): Promise<UserDto> {
    const user = await this.userRepository.findById(id);

    if (!user) {
      throw new NotFoundError(`用户不存在，用户ID: ${id}`);
    }

    return this.mapToDto(user);
  }

  /**
   * 创建用户
   * @param userData 用户数据
   * @returns 创建的用户
   */
  public async createUser(userData: CreateUserDto): Promise<UserDto> {
    // 检查邮箱是否已存在
    const existingUser = await this.userRepository.findByEmail(userData.email);
    if (existingUser) {
      throw new BadRequestError('邮箱已被使用');
    }

    // 检查手机号是否已存在
    const existingPhone = await this.userRepository.findByPhone(userData.phone);
    if (existingPhone) {
      throw new BadRequestError('手机号已被使用');
    }

    // 加密密码
    const hashedPassword = await hashPassword(userData.password);

    // 创建用户
    const user = await this.userRepository.create({
      ...userData,
      password: hashedPassword,
      status: 'active'
    });

    logger.info('创建用户成功', { userId: user.id, email: user.email });

    return this.mapToDto(user);
  }

  /**
   * 更新用户
   * @param id 用户ID
   * @param userData 用户数据
   * @returns 更新后的用户
   */
  public async updateUser(id: string, userData: UpdateUserDto): Promise<UserDto> {
    // 检查用户是否存在
    const existingUser = await this.userRepository.findById(id);
    if (!existingUser) {
      throw new NotFoundError(`用户不存在，用户ID: ${id}`);
    }

    // 检查邮箱是否已被其他用户使用
    if (userData.email && userData.email !== existingUser.email) {
      const userWithSameEmail = await this.userRepository.findByEmail(userData.email);
      if (userWithSameEmail) {
        throw new BadRequestError('邮箱已被使用');
      }
    }

    // 检查手机号是否已被其他用户使用
    if (userData.phone && userData.phone !== existingUser.phone) {
      const userWithSamePhone = await this.userRepository.findByPhone(userData.phone);
      if (userWithSamePhone) {
        throw new BadRequestError('手机号已被使用');
      }
    }

    // 更新用户
    const updatedUser = await this.userRepository.update(id, userData);

    logger.info('更新用户成功', { userId: updatedUser.id });

    return this.mapToDto(updatedUser);
  }

  /**
   * 删除用户
   * @param id 用户ID
   */
  public async deleteUser(id: string): Promise<void> {
    // 检查用户是否存在
    const existingUser = await this.userRepository.findById(id);
    if (!existingUser) {
      throw new NotFoundError(`用户不存在，用户ID: ${id}`);
    }

    // 删除用户
    await this.userRepository.delete(id);

    logger.info('删除用户成功', { userId: id });
  }

  /**
   * 将用户模型映射为DTO
   * @param user 用户模型
   * @returns 用户DTO
   */
  private mapToDto(user: User): UserDto {
    return {
      id: user.id,
      name: user.name,
      email: user.email,
      phone: user.phone,
      status: user.status,
      roleId: user.roleId,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    };
  }
}
```

### 12.4 仓库模板

```typescript
/**
 * @file userRepository.ts
 * @description 用户仓库
 * @author YYC³团队
 * @version 1.0.0
 */

import { User } from '../models/user';
import { CreateUserDto, UpdateUserDto } from '../dtos/userDto';
import { logger } from '../utils/logger';

/**
 * 用户仓库类
 */
export class UserRepository {
  /**
   * 获取用户列表
   * @param limit 每页数量
   * @param offset 偏移量
   * @returns 用户列表
   */
  public async findAll(limit: number, offset: number): Promise<User[]> {
    try {
      return await User.findAll({
        limit,
        offset,
        order: [['createdAt', 'DESC']]
      });
    } catch (error) {
      logger.error('获取用户列表失败', error);
      throw error;
    }
  }

  /**
   * 获取用户总数
   * @returns 用户总数
   */
  public async count(): Promise<number> {
    try {
      return await User.count();
    } catch (error) {
      logger.error('获取用户总数失败', error);
      throw error;
    }
  }

  /**
   * 根据ID获取用户
   * @param id 用户ID
   * @returns 用户
   */
  public async findById(id: string): Promise<User | null> {
    try {
      return await User.findByPk(id);
    } catch (error) {
      logger.error(`根据ID获取用户失败，用户ID: ${id}`, error);
      throw error;
    }
  }

  /**
   * 根据邮箱获取用户
   * @param email 用户邮箱
   * @returns 用户
   */
  public async findByEmail(email: string): Promise<User | null> {
    try {
      return await User.findOne({
        where: { email }
      });
    } catch (error) {
      logger.error(`根据邮箱获取用户失败，邮箱: ${email}`, error);
      throw error;
    }
  }

  /**
   * 根据手机号获取用户
   * @param phone 用户手机号
   * @returns 用户
   */
  public async findByPhone(phone: string): Promise<User | null> {
    try {
      return await User.findOne({
        where: { phone }
      });
    } catch (error) {
      logger.error(`根据手机号获取用户失败，手机号: ${phone}`, error);
      throw error;
    }
  }

  /**
   * 创建用户
   * @param userData 用户数据
   * @returns 创建的用户
   */
  public async create(userData: CreateUserDto): Promise<User> {
    try {
      return await User.create(userData);
    } catch (error) {
      logger.error('创建用户失败', error);
      throw error;
    }
  }

  /**
   * 更新用户
   * @param id 用户ID
   * @param userData 用户数据
   * @returns 更新后的用户
   */
  public async update(id: string, userData: UpdateUserDto): Promise<User> {
    try {
      const user = await this.findById(id);
      if (!user) {
        throw new Error(`用户不存在，用户ID: ${id}`);
      }

      await user.update(userData);
      return user;
    } catch (error) {
      logger.error(`更新用户失败，用户ID: ${id}`, error);
      throw error;
    }
  }

  /**
   * 删除用户
   * @param id 用户ID
   */
  public async delete(id: string): Promise<void> {
    try {
      const user = await this.findById(id);
      if (!user) {
        throw new Error(`用户不存在，用户ID: ${id}`);
      }

      await user.destroy();
    } catch (error) {
      logger.error(`删除用户失败，用户ID: ${id}`, error);
      throw error;
    }
  }
}
```

### 12.5 模型模板

```typescript
/**
 * @file user.ts
 * @description 用户模型
 * @author YYC³团队
 * @version 1.0.0
 */

import { Model, DataTypes, Optional } from 'sequelize';
import { sequelize } from '../config/database';

/**
 * 用户属性接口
 */
export interface UserAttributes {
  id: string;
  name: string;
  email: string;
  phone: string;
  password: string;
  status: string;
  roleId: string;
  createdAt: Date;
  updatedAt: Date;
}

/**
 * 用户创建属性接口
 */
export interface UserCreationAttributes extends Optional<UserAttributes, 'id' | 'createdAt' | 'updatedAt'> {}

/**
 * 用户模型
 */
export class User extends Model<UserAttributes, UserCreationAttributes> implements UserAttributes {
  public id!: string;
  public name!: string;
  public email!: string;
  public phone!: string;
  public password!: string;
  public status!: string;
  public roleId!: string;

  public readonly createdAt!: Date;
  public readonly updatedAt!: Date;
}

// 初始化用户模型
User.init(
  {
    id: {
      type: DataTypes.UUID,
      defaultValue: DataTypes.UUIDV4,
      primaryKey: true,
      allowNull: false
    },
    name: {
      type: DataTypes.STRING(50),
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [2, 50]
      }
    },
    email: {
      type: DataTypes.STRING(100),
      allowNull: false,
      unique: true,
      validate: {
        notEmpty: true,
        isEmail: true,
        len: [5, 100]
      }
    },
    phone: {
      type: DataTypes.STRING(11),
      allowNull: false,
      unique: true,
      validate: {
        notEmpty: true,
        len: [11, 11]
      }
    },
    password: {
      type: DataTypes.STRING(100),
      allowNull: false,
      validate: {
        notEmpty: true,
        len: [8, 100]
      }
    },
    status: {
      type: DataTypes.STRING(20),
      allowNull: false,
      defaultValue: 'active',
      validate: {
        notEmpty: true,
        isIn: [['active', 'inactive', 'suspended']]
      }
    },
    roleId: {
      type: DataTypes.UUID,
      allowNull: false
    },
    createdAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW
    },
    updatedAt: {
      type: DataTypes.DATE,
      allowNull: false,
      defaultValue: DataTypes.NOW,
      onUpdate: DataTypes.NOW
    }
  },
  {
    sequelize,
    tableName: 'users',
    timestamps: true,
    paranoid: false,
    charset: 'utf8mb4',
    collate: 'utf8mb4_unicode_ci'
  }
);
```

### 12.6 类型定义模板

```typescript
/**
 * @file pagination.ts
 * @description 分页类型定义
 * @author YYC³团队
 * @version 1.0.0
 */

/**
 * 分页选项
 */
export interface PaginationOptions {
  /** 页码 */
  page: number;
  /** 每页数量 */
  limit: number;
}

/**
 * 分页结果
 */
export interface PaginationResult<T> {
  /** 数据列表 */
  data: T[];
  /** 分页信息 */
  pagination: {
    /** 当前页码 */
    page: number;
    /** 每页数量 */
    limit: number;
    /** 总数量 */
    total: number;
    /** 总页数 */
    totalPages: number;
  };
}
```

### 12.7 路由模板

```typescript
/**
 * @file userRoutes.ts
 * @description 用户路由
 * @author YYC³团队
 * @version 1.0.0
 */

import { Router } from 'express';
import { UserController } from '../controllers/userController';
import { authMiddleware } from '../middleware/authMiddleware';
import { validateCreateUser, validateUpdateUser } from '../validators/userValidators';

const router = Router();
const userController = new UserController();

// 保护所有路由
router.use(authMiddleware);

// 路由定义
router.get('/', userController.getUsers);
router.get('/:id', userController.getUserById);
router.post('/', validateCreateUser, userController.createUser);
router.put('/:id', validateUpdateUser, userController.updateUser);
router.delete('/:id', userController.deleteUser);

export { router as userRoutes };
```

### 12.8 中间件模板

```typescript
/**
 * @file authMiddleware.ts
 * @description 认证中间件
 * @author YYC³团队
 * @version 1.0.0
 */

import { Request, Response, NextFunction } from 'express';
import { verifyToken } from '../utils/jwtUtils';
import { UnauthorizedError } from '../errors/UnauthorizedError';
import { logger } from '../utils/logger';

/**
 * 认证中间件
 * @param req 请求对象
 * @param res 响应对象
 * @param next 中间件函数
 */
export const authMiddleware = (req: Request, res: Response, next: NextFunction): void => {
  try {
    // 从请求头获取token
    const authHeader = req.header('Authorization');
    if (!authHeader) {
      throw new UnauthorizedError('缺少认证token');
    }

    // 提取token
    const [bearer, token] = authHeader.split(' ');
    if (bearer !== 'Bearer' || !token) {
      throw new UnauthorizedError('无效的认证格式');
    }

    // 验证token
    const decoded = verifyToken(token);

    // 将用户信息添加到请求对象
    req.user = decoded;

    next();
  } catch (error) {
    logger.error('认证失败', error);
    next(error);
  }
};
```

### 12.9 配置模板

```typescript
/**
 * @file config.ts
 * @description 配置管理
 * @author YYC³团队
 * @version 1.0.0
 */

import dotenv from 'dotenv';
import path from 'path';
import { z } from 'zod';
import { logger } from './utils/logger';

// 加载环境变量
dotenv.config({
  path: path.resolve(process.cwd(), '.env')
});

// 配置验证模式
const configSchema = z.object({
  // 服务信息
  service: z.object({
    name: z.string().default('microservice-template'),
    version: z.string().default('1.0.0'),
    environment: z.enum(['development', 'testing', 'staging', 'production']).default('development'),
    description: z.string().optional()
  }),

  // 服务器配置
  server: z.object({
    host: z.string().default('0.0.0.0'),
    port: z.number().int().default(3200),
    keepAliveTimeout: z.number().int().default(60000)
  }),

  // API配置
  api: z.object({
    prefix: z.string().default('/api'),
    version: z.string().default('v1'),
    timeout: z.number().int().default(30000)
  }),

  // 数据库配置
  database: z.object({
    url: z.string().optional(),
    host: z.string().optional(),
    port: z.number().int().optional(),
    name: z.string().optional(),
    username: z.string().optional(),
    password: z.string().optional(),
    dialect: z.enum(['mysql', 'postgres', 'sqlite', 'mssql']).default('mysql'),
    logging: z.boolean().default(false),
    sync: z.boolean().default(false)
  }),

  // CORS配置
  cors: z.object({
    enabled: z.boolean().default(true),
    origins: z.array(z.string()).default(['*']),
    credentials: z.boolean().default(true),
    methods: z.array(z.string()).default(['GET', 'POST', 'PUT', 'DELETE', 'OPTIONS']),
    headers: z.array(z.string()).default(['Content-Type', 'Authorization', 'X-Requested-With'])
  }),

  // 请求配置
  request: z.object({
    bodyLimit: z.string().default('10mb')
  }),

  // 日志配置
  logger: z.object({
    level: z.enum(['debug', 'info', 'warn', 'error']).default('info'),
    format: z.enum(['json', 'console']).default('json'),
    fileLogging: z.boolean().default(false),
    logDirectory: z.string().default('./logs')
  }),

  // 认证配置
  auth: z.object({
    jwtSecret: z.string(),
    jwtExpiresIn: z.string().default('24h'),
    jwtRefreshExpiresIn: z.string().default('7d'),
    bcryptSaltRounds: z.number().int().default(12)
  }),

  // 分页配置
  pagination: z.object({
    defaultPage: z.number().int().default(1),
    defaultLimit: z.number().int().default(10),
    maxLimit: z.number().int().default(100)
  })
});

// 解析配置
const parseConfig = () => {
  try {
    const config = {
      service: {
        name: process.env.SERVICE_NAME,
        version: process.env.SERVICE_VERSION,
        environment: process.env.NODE_ENV,
        description: process.env.SERVICE_DESCRIPTION
      },
      server: {
        host: process.env.SERVER_HOST,
        port: parseInt(process.env.SERVER_PORT || '3200'),
        keepAliveTimeout: parseInt(process.env.SERVER_KEEP_ALIVE_TIMEOUT || '60000')
      },
      api: {
        prefix: process.env.API_PREFIX,
        version: process.env.API_VERSION,
        timeout: parseInt(process.env.API_TIMEOUT || '30000')
      },
      database: {
        url: process.env.DATABASE_URL,
        host: process.env.DATABASE_HOST,
        port: process.env.DATABASE_PORT ? parseInt(process.env.DATABASE_PORT) : undefined,
        name: process.env.DATABASE_NAME,
        username: process.env.DATABASE_USERNAME,
        password: process.env.DATABASE_PASSWORD,
        dialect: process.env.DATABASE_DIALECT as any,
        logging: process.env.DATABASE_LOGGING === 'true',
        sync: process.env.DATABASE_SYNC === 'true'
      },
      cors: {
        enabled: process.env.CORS_ENABLED !== 'false',
        origins: process.env.CORS_ORIGINS ? process.env.CORS_ORIGINS.split(',') : undefined,
        credentials: process.env.CORS_CREDENTIALS !== 'false',
        methods: process.env.CORS_METHODS ? process.env.CORS_METHODS.split(',') : undefined,
        headers: process.env.CORS_HEADERS ? process.env.CORS_HEADERS.split(',') : undefined
      },
      request: {
        bodyLimit: process.env.REQUEST_BODY_LIMIT
      },
      logger: {
        level: process.env.LOGGER_LEVEL as any,
        format: process.env.LOGGER_FORMAT as any,
        fileLogging: process.env.LOGGER_FILE_LOGGING === 'true',
        logDirectory: process.env.LOGGER_DIRECTORY
      },
      auth: {
        jwtSecret: process.env.JWT_SECRET,
        jwtExpiresIn: process.env.JWT_EXPIRES_IN,
        jwtRefreshExpiresIn: process.env.JWT_REFRESH_EXPIRES_IN,
        bcryptSaltRounds: parseInt(process.env.BCRYPT_SALT_ROUNDS || '12')
      },
      pagination: {
        defaultPage: parseInt(process.env.PAGINATION_DEFAULT_PAGE || '1'),
        defaultLimit: parseInt(process.env.PAGINATION_DEFAULT_LIMIT || '10'),
        maxLimit: parseInt(process.env.PAGINATION_MAX_LIMIT || '100')
      }
    };

    // 验证配置
    const validatedConfig = configSchema.parse(config);
    return validatedConfig;
  } catch (error) {
    logger.error('配置验证失败', error);
    throw error;
  }
};

// 导出配置
export const config = parseConfig();
```

## 13. 总结

本文档定义了智能餐饮平台微服务开发的规范和模板，包括命名规范、项目结构、代码风格、API设计、数据库设计、错误处理、日志规范、测试规范、安全规范、部署和监控规范等内容。所有参与智能餐饮平台开发的团队和个人必须严格遵守本规范，确保所有微服务遵循统一的开发标准，提高代码质量、可维护性和可扩展性。

本规范支持Java和Node.js/Express两种技术栈，开发团队可以根据项目需求选择合适的技术栈。

本规范将定期更新和完善，以适应智能餐饮平台的发展需求。

---

**文档版本**: 1.0.0  
**最后更新**: 2025-01-30  
**维护责任人**: YYC³团队