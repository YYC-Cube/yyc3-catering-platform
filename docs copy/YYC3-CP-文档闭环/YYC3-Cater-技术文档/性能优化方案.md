# YYCÂ³ é¤é¥®å¹³å° - æ€§èƒ½ä¼˜åŒ–æ–¹æ¡ˆ

## ğŸ“Š æ‰§è¡Œæ‘˜è¦

**åˆ›å»ºæ—¥æœŸ**: 2026-01-20  
**ä¼˜åŒ–ç›®æ ‡**: æå‡ç³»ç»Ÿæ•´ä½“æ€§èƒ½ï¼Œä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢å’Œå‰ç«¯æ¸²æŸ“  
**é¢„æœŸæå‡**: 
- æ•°æ®åº“æŸ¥è¯¢é€Ÿåº¦æå‡ 50%+
- å‰ç«¯é¦–å±åŠ è½½æ—¶é—´å‡å°‘ 40%+
- APIå“åº”æ—¶é—´å‡å°‘ 30%+
- ç³»ç»Ÿååé‡æå‡ 100%+

---

## ğŸ¯ ä¼˜åŒ–ç›®æ ‡

### æ•°æ®åº“ä¼˜åŒ–

1. æŸ¥è¯¢ä¼˜åŒ–
   - å‡å°‘N+1æŸ¥è¯¢é—®é¢˜
   - ä¼˜åŒ–å¤æ‚æŸ¥è¯¢
   - æ·»åŠ é€‚å½“çš„ç´¢å¼•

2. è¿æ¥æ± ä¼˜åŒ–
   - è°ƒæ•´è¿æ¥æ± å¤§å°
   - å®ç°è¿æ¥å¤ç”¨
   - ä¼˜åŒ–è¿æ¥è¶…æ—¶è®¾ç½®

3. ç¼“å­˜ç­–ç•¥
   - å®ç°Redisç¼“å­˜
   - å®ç°æŸ¥è¯¢ç»“æœç¼“å­˜
   - å®ç°ä¼šè¯ç¼“å­˜

### å‰ç«¯ä¼˜åŒ–

1. ä»£ç åˆ†å‰²
   - å®ç°è·¯ç”±çº§ä»£ç åˆ†å‰²
   - å®ç°ç»„ä»¶çº§ä»£ç åˆ†å‰²
   - å®ç°æ‡’åŠ è½½

2. èµ„æºä¼˜åŒ–
   - å‹ç¼©å’Œä¼˜åŒ–å›¾ç‰‡
   - å¯ç”¨Gzipå‹ç¼©
   - ä½¿ç”¨CDNåŠ é€Ÿ

3. æ¸²æŸ“ä¼˜åŒ–
   - å®ç°è™šæ‹Ÿæ»šåŠ¨
   - ä¼˜åŒ–ç»„ä»¶æ¸²æŸ“
   - å‡å°‘ä¸å¿…è¦çš„é‡æ¸²æŸ“

### APIä¼˜åŒ–

1. å“åº”ä¼˜åŒ–
   - å®ç°å“åº”å‹ç¼©
   - ä¼˜åŒ–å“åº”æ ¼å¼
   - å®ç°åˆ†é¡µå’Œè¿‡æ»¤

2. å¹¶å‘ä¼˜åŒ–
   - å®ç°è¯·æ±‚å¹¶å‘æ§åˆ¶
   - å®ç°è¯·æ±‚åˆå¹¶
   - å®ç°è¯·æ±‚å»é‡

---

## ğŸ”§ æ•°æ®åº“ä¼˜åŒ–æ–¹æ¡ˆ

### 1. ç´¢å¼•ä¼˜åŒ–

#### 1.1 è®¢å•è¡¨ç´¢å¼•

```sql
-- ä¸»é”®ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_orders_id ON orders(id);

-- ç”¨æˆ·IDç´¢å¼•ï¼ˆé«˜é¢‘æŸ¥è¯¢ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_user_id ON orders(user_id);

-- åˆ›å»ºæ—¶é—´ç´¢å¼•ï¼ˆæ—¶é—´èŒƒå›´æŸ¥è¯¢ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_created_at ON orders(created_at DESC);

-- å¤åˆç´¢å¼•ï¼ˆç”¨æˆ·+æ—¶é—´+çŠ¶æ€ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_user_created_status 
ON orders(user_id, created_at DESC, status);

-- çŠ¶æ€ç´¢å¼•ï¼ˆçŠ¶æ€è¿‡æ»¤ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_status ON orders(status);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆä»…æ´»è·ƒè®¢å•ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_active 
ON orders(created_at DESC) 
WHERE status IN ('pending', 'preparing', 'ready');

-- è¡¨è¾¾å¼ç´¢å¼•ï¼ˆæ—¥æœŸèŒƒå›´ï¼‰
CREATE INDEX CONCURRENTLY idx_orders_date_range 
ON orders(date_trunc('day', created_at));
```

#### 1.2 å®¢æˆ·è¡¨ç´¢å¼•

```sql
-- ä¸»é”®ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_customers_id ON customers(id);

-- é‚®ç®±ç´¢å¼•ï¼ˆå”¯ä¸€ï¼‰
CREATE UNIQUE INDEX CONCURRENTLY idx_customers_email ON customers(email);

-- æ‰‹æœºå·ç´¢å¼•ï¼ˆå”¯ä¸€ï¼‰
CREATE UNIQUE INDEX CONCURRENTLY idx_customers_phone ON customers(phone);

-- ç”Ÿå‘½å‘¨æœŸé˜¶æ®µç´¢å¼•
CREATE INDEX CONCURRENTLY idx_customers_lifecycle_stage 
ON customers(lifecycle_stage);

-- åˆ›å»ºæ—¶é—´ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_customers_created_at 
ON customers(created_at DESC);

-- å¤åˆç´¢å¼•ï¼ˆç”Ÿå‘½å‘¨æœŸ+åˆ›å»ºæ—¶é—´ï¼‰
CREATE INDEX CONCURRENTLY idx_customers_lifecycle_created 
ON customers(lifecycle_stage, created_at DESC);
```

#### 1.3 èœå“è¡¨ç´¢å¼•

```sql
-- ä¸»é”®ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_menu_items_id ON menu_items(id);

-- åˆ†ç±»IDç´¢å¼•
CREATE INDEX CONCURRENTLY idx_menu_items_category_id 
ON menu_items(category_id);

-- çŠ¶æ€ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_menu_items_status ON menu_items(status);

-- ä»·æ ¼ç´¢å¼•ï¼ˆèŒƒå›´æŸ¥è¯¢ï¼‰
CREATE INDEX CONCURRENTLY idx_menu_items_price ON menu_items(price);

-- å¤åˆç´¢å¼•ï¼ˆåˆ†ç±»+çŠ¶æ€ï¼‰
CREATE INDEX CONCURRENTLY idx_menu_items_category_status 
ON menu_items(category_id, status);

-- å…¨æ–‡æœç´¢ç´¢å¼•ï¼ˆåç§°å’Œæè¿°ï¼‰
CREATE INDEX CONCURRENTLY idx_menu_items_search 
ON menu_items USING gin(to_tsvector('chinese', name || ' ' || description));
```

#### 1.4 å¨æˆ¿è®¢å•è¡¨ç´¢å¼•

```sql
-- ä¸»é”®ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_kitchen_orders_id ON kitchen_orders(id);

-- è®¢å•IDç´¢å¼•
CREATE INDEX CONCURRENTLY idx_kitchen_orders_order_id 
ON kitchen_orders(order_id);

-- çŠ¶æ€ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_kitchen_orders_status 
ON kitchen_orders(status);

-- åˆ›å»ºæ—¶é—´ç´¢å¼•
CREATE INDEX CONCURRENTLY idx_kitchen_orders_created_at 
ON kitchen_orders(created_at DESC);

-- å¤åˆç´¢å¼•ï¼ˆçŠ¶æ€+åˆ›å»ºæ—¶é—´ï¼‰
CREATE INDEX CONCURRENTLY idx_kitchen_orders_status_created 
ON kitchen_orders(status, created_at DESC);

-- éƒ¨åˆ†ç´¢å¼•ï¼ˆä»…è¿›è¡Œä¸­è®¢å•ï¼‰
CREATE INDEX CONCURRENTLY idx_kitchen_orders_in_progress 
ON kitchen_orders(created_at DESC) 
WHERE status IN ('pending', 'preparing', 'cooking');
```

### 2. æŸ¥è¯¢ä¼˜åŒ–

#### 2.1 è®¢å•æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šN+1æŸ¥è¯¢é—®é¢˜
async function getOrdersWithDetails(userId: string) {
  const orders = await db.query(
    'SELECT * FROM orders WHERE user_id = $1 ORDER BY created_at DESC',
    [userId]
  );
  
  for (const order of orders) {
    order.items = await db.query(
      'SELECT * FROM order_items WHERE order_id = $1',
      [order.id]
    );
    order.customer = await db.query(
      'SELECT * FROM customers WHERE id = $1',
      [order.customer_id]
    );
  }
  
  return orders;
}

// ä¼˜åŒ–åï¼šä½¿ç”¨JOIN
async function getOrdersWithDetails(userId: string, limit = 20, offset = 0) {
  const query = `
    SELECT 
      o.*,
      json_agg(
        json_build_object(
          'id', oi.id,
          'menu_item_id', oi.menu_item_id,
          'quantity', oi.quantity,
          'price', oi.price,
          'name', mi.name,
          'description', mi.description
        )
      ) as items,
      json_build_object(
        'id', c.id,
        'name', c.name,
        'email', c.email,
        'phone', c.phone,
        'lifecycle_stage', c.lifecycle_stage
      ) as customer
    FROM orders o
    LEFT JOIN order_items oi ON o.id = oi.order_id
    LEFT JOIN menu_items mi ON oi.menu_item_id = mi.id
    LEFT JOIN customers c ON o.customer_id = c.id
    WHERE o.user_id = $1
    GROUP BY o.id, c.id
    ORDER BY o.created_at DESC
    LIMIT $2 OFFSET $3
  `;
  
  return await db.query(query, [userId, limit, offset]);
}
```

#### 2.2 å®¢æˆ·æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šå¤šæ¬¡æŸ¥è¯¢
async function getCustomerStats(customerId: string) {
  const customer = await db.query(
    'SELECT * FROM customers WHERE id = $1',
    [customerId]
  );
  
  const totalOrders = await db.query(
    'SELECT COUNT(*) FROM orders WHERE customer_id = $1',
    [customerId]
  );
  
  const totalSpent = await db.query(
    'SELECT SUM(total_amount) FROM orders WHERE customer_id = $1',
    [customerId]
  );
  
  const lastOrder = await db.query(
    'SELECT * FROM orders WHERE customer_id = $1 ORDER BY created_at DESC LIMIT 1',
    [customerId]
  );
  
  return {
    ...customer,
    stats: {
      totalOrders: totalOrders[0].count,
      totalSpent: totalSpent[0].sum || 0,
      lastOrderAt: lastOrder[0]?.created_at
    }
  };
}

// ä¼˜åŒ–åï¼šå•æ¬¡æŸ¥è¯¢
async function getCustomerStats(customerId: string) {
  const query = `
    SELECT 
      c.*,
      COALESCE(o.total_orders, 0) as total_orders,
      COALESCE(o.total_spent, 0) as total_spent,
      o.last_order_at
    FROM customers c
    LEFT JOIN (
      SELECT 
        customer_id,
        COUNT(*) as total_orders,
        SUM(total_amount) as total_spent,
        MAX(created_at) as last_order_at
      FROM orders
      WHERE customer_id = $1
      GROUP BY customer_id
    ) o ON c.id = o.customer_id
    WHERE c.id = $1
  `;
  
  return await db.query(query, [customerId]);
}
```

#### 2.3 èœå•æŸ¥è¯¢ä¼˜åŒ–

```typescript
// ä¼˜åŒ–å‰ï¼šæ— åˆ†é¡µ
async function getMenuItems(categoryId?: string) {
  let query = 'SELECT * FROM menu_items WHERE status = $1';
  const params = ['active'];
  
  if (categoryId) {
    query += ' AND category_id = $2';
    params.push(categoryId);
  }
  
  return await db.query(query, params);
}

// ä¼˜åŒ–åï¼šåˆ†é¡µ+ç¼“å­˜
async function getMenuItems(
  categoryId?: string,
  page = 1,
  limit = 20
) {
  const cacheKey = `menu_items:${categoryId || 'all'}:${page}:${limit}`;
  
  // å°è¯•ä»ç¼“å­˜è·å–
  const cached = await redis.get(cacheKey);
  if (cached) {
    return JSON.parse(cached);
  }
  
  const offset = (page - 1) * limit;
  let query = `
    SELECT 
      mi.*,
      c.name as category_name,
      c.slug as category_slug
    FROM menu_items mi
    LEFT JOIN categories c ON mi.category_id = c.id
    WHERE mi.status = $1
  `;
  const params = ['active'];
  
  if (categoryId) {
    query += ' AND mi.category_id = $2';
    params.push(categoryId);
  }
  
  query += ' ORDER BY mi.sort_order, mi.id LIMIT $3 OFFSET $4';
  params.push(limit, offset);
  
  const result = await db.query(query, params);
  
  // ç¼“å­˜ç»“æœï¼ˆ5åˆ†é’Ÿï¼‰
  await redis.setex(cacheKey, 300, JSON.stringify(result));
  
  return result;
}
```

### 3. è¿æ¥æ± ä¼˜åŒ–

```typescript
// database.ts
import { Pool, PoolConfig } from 'pg';

const poolConfig: PoolConfig = {
  host: process.env.DB_HOST || 'localhost',
  port: parseInt(process.env.DB_PORT || '5432'),
  database: process.env.DB_NAME || 'yyc3_catering',
  user: process.env.DB_USER || 'postgres',
  password: process.env.DB_PASSWORD || '',
  
  // è¿æ¥æ± é…ç½®
  max: 20, // æœ€å¤§è¿æ¥æ•°
  min: 5,  // æœ€å°è¿æ¥æ•°
  idleTimeoutMillis: 30000, // ç©ºé—²è¿æ¥è¶…æ—¶ï¼ˆ30ç§’ï¼‰
  connectionTimeoutMillis: 10000, // è¿æ¥è¶…æ—¶ï¼ˆ10ç§’ï¼‰
  
  // è¿æ¥éªŒè¯
  idle: 10000, // è¿æ¥ç©ºé—²æ£€æŸ¥é—´éš”ï¼ˆ10ç§’ï¼‰
  
  // æŸ¥è¯¢è¶…æ—¶
  statement_timeout: 30000, // æŸ¥è¯¢è¶…æ—¶ï¼ˆ30ç§’ï¼‰
  query_timeout: 30000, // æŸ¥è¯¢è¶…æ—¶ï¼ˆ30ç§’ï¼‰
  
  // æ—¥å¿—
  log: (msg) => {
    console.log('[Database]', msg);
  }
};

export const pool = new Pool(poolConfig);

// è¿æ¥æ± ç›‘æ§
setInterval(() => {
  const totalCount = pool.totalCount;
  const idleCount = pool.idleCount;
  const waitingCount = pool.waitingCount;
  
  console.log('[Pool]', {
    total: totalCount,
    idle: idleCount,
    active: totalCount - idleCount,
    waiting: waitingCount
  });
}, 60000); // æ¯åˆ†é’Ÿè¾“å‡ºä¸€æ¬¡
```

### 4. ç¼“å­˜ç­–ç•¥

```typescript
// cache.ts
import Redis from 'ioredis';

const redis = new Redis({
  host: process.env.REDIS_HOST || 'localhost',
  port: parseInt(process.env.REDIS_PORT || '6379'),
  password: process.env.REDIS_PASSWORD || '',
  db: parseInt(process.env.REDIS_DB || '0'),
  
  // è¿æ¥æ± é…ç½®
  maxRetriesPerRequest: 3,
  retryStrategy: (times) => Math.min(times * 50, 2000),
  
  // æ€§èƒ½ä¼˜åŒ–
  enableReadyCheck: true,
  enableOfflineQueue: true,
  lazyConnect: false
});

// ç¼“å­˜é…ç½®
const CACHE_TTL = {
  SHORT: 60, // 1åˆ†é’Ÿ
  MEDIUM: 300, // 5åˆ†é’Ÿ
  LONG: 3600, // 1å°æ—¶
  VERY_LONG: 86400 // 24å°æ—¶
};

// ç¼“å­˜è¾…åŠ©å‡½æ•°
export const cache = {
  async get<T>(key: string): Promise<T | null> {
    const data = await redis.get(key);
    return data ? JSON.parse(data) : null;
  },
  
  async set(key: string, value: any, ttl: number = CACHE_TTL.MEDIUM): Promise<void> {
    await redis.setex(key, ttl, JSON.stringify(value));
  },
  
  async del(key: string): Promise<void> {
    await redis.del(key);
  },
  
  async delPattern(pattern: string): Promise<void> {
    const keys = await redis.keys(pattern);
    if (keys.length > 0) {
      await redis.del(...keys);
    }
  },
  
  async invalidateCache(prefix: string, id?: string): Promise<void> {
    if (id) {
      await this.del(`${prefix}:${id}`);
    } else {
      await this.delPattern(`${prefix}:*`);
    }
  }
};

export { redis, CACHE_TTL };
```

---

## ğŸ¨ å‰ç«¯ä¼˜åŒ–æ–¹æ¡ˆ

### 1. ä»£ç åˆ†å‰²

#### 1.1 è·¯ç”±çº§ä»£ç åˆ†å‰²

```typescript
// router.ts
import { createRouter, createWebHistory } from 'vue-router';

const routes = [
  {
    path: '/',
    name: 'Dashboard',
    component: () => import('@/views/Dashboard.vue') // æ‡’åŠ è½½
  },
  {
    path: '/orders',
    name: 'Orders',
    component: () => import('@/views/OrderManagement.vue') // æ‡’åŠ è½½
  },
  {
    path: '/kitchen',
    name: 'Kitchen',
    component: () => import('@/views/KitchenManagement.vue') // æ‡’åŠ è½½
  },
  {
    path: '/customers',
    name: 'Customers',
    component: () => import('@/views/CustomerManagement.vue') // æ‡’åŠ è½½
  },
  {
    path: '/menu',
    name: 'Menu',
    component: () => import('@/views/MenuManagement.vue') // æ‡’åŠ è½½
  }
];

const router = createRouter({
  history: createWebHistory(),
  routes
});

export default router;
```

#### 1.2 ç»„ä»¶çº§ä»£ç åˆ†å‰²

```vue
<!-- OrderList.vue -->
<template>
  <div>
    <OrderFilters />
    <OrderTable />
    <OrderPagination />
    
    <!-- æ‡’åŠ è½½è¯¦æƒ…ç»„ä»¶ -->
    <AsyncOrderDetail v-if="showDetail" :order-id="selectedOrderId" />
  </div>
</template>

<script setup lang="ts">
import { defineAsyncComponent, ref } from 'vue';

// æ‡’åŠ è½½è¯¦æƒ…ç»„ä»¶
const AsyncOrderDetail = defineAsyncComponent({
  loader: () => import('./OrderDetail.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorComponent,
  delay: 200,
  timeout: 3000
});

const showDetail = ref(false);
const selectedOrderId = ref<string | null>(null);
</script>
```

### 2. èµ„æºä¼˜åŒ–

#### 2.1 å›¾ç‰‡ä¼˜åŒ–

```typescript
// utils/imageOptimizer.ts
import sharp from 'sharp';

export async function optimizeImage(
  input: Buffer,
  options: {
    width?: number;
    height?: number;
    quality?: number;
    format?: 'jpeg' | 'png' | 'webp';
  } = {}
): Promise<Buffer> {
  const {
    width = 800,
    height = 600,
    quality = 80,
    format = 'webp'
  } = options;
  
  let pipeline = sharp(input);
  
  // è°ƒæ•´å°ºå¯¸
  if (width || height) {
    pipeline = pipeline.resize(width, height, {
      fit: 'inside',
      withoutEnlargement: true
    });
  }
  
  // è½¬æ¢æ ¼å¼
  if (format === 'webp') {
    pipeline = pipeline.webp({ quality });
  } else if (format === 'jpeg') {
    pipeline = pipeline.jpeg({ quality });
  } else if (format === 'png') {
    pipeline = pipeline.png({ quality });
  }
  
  return await pipeline.toBuffer();
}

// ä½¿ç”¨ç¤ºä¾‹
const optimizedImage = await optimizeImage(originalImage, {
  width: 800,
  height: 600,
  quality: 80,
  format: 'webp'
});
```

#### 2.2 Gzipå‹ç¼©

```typescript
// middleware/compression.ts
import compression from 'compression';

export const compressionMiddleware = compression({
  // å‹ç¼©é˜ˆå€¼ï¼ˆ1KBï¼‰
  threshold: 1024,
  
  // å‹ç¼©çº§åˆ«ï¼ˆ1-9ï¼‰
  level: 6,
  
  // å‹ç¼©çš„æ–‡ä»¶ç±»å‹
  filter: (req, res) => {
    if (req.headers['x-no-compression']) {
      return false;
    }
    
    const type = res.getHeader('Content-Type') as string;
    return /text|javascript|json|css|svg/.test(type);
  }
});
```

### 3. æ¸²æŸ“ä¼˜åŒ–

#### 3.1 è™šæ‹Ÿæ»šåŠ¨

```vue
<!-- OrderTable.vue -->
<template>
  <div class="order-table">
    <VirtualList
      :data-sources="orders"
      :data-key="'id'"
      :keeps="30"
      :estimate-size="50"
      :extra-props="{ onSelect }"
    >
      <template #default="{ data }">
        <OrderItem :order="data" @select="onSelect" />
      </template>
    </VirtualList>
  </div>
</template>

<script setup lang="ts">
import { ref } from 'vue';
import VirtualList from 'vue-virtual-scroll-list';
import OrderItem from './OrderItem.vue';

const orders = ref<Order[]>([]);

// è·å–è®¢å•æ•°æ®
async function fetchOrders() {
  const response = await api.getOrders();
  orders.value = response.data;
}

// é€‰æ‹©è®¢å•
function onSelect(order: Order) {
  console.log('Selected:', order);
}
</script>
```

#### 3.2 ç»„ä»¶ä¼˜åŒ–

```vue
<!-- OrderItem.vue -->
<template>
  <div class="order-item">
    <div class="order-info">
      <span class="order-id">{{ order.id }}</span>
      <span class="order-status">{{ order.status }}</span>
    </div>
    <div class="order-details">
      <span class="order-customer">{{ order.customerName }}</span>
      <span class="order-amount">{{ order.totalAmount }}</span>
    </div>
  </div>
</template>

<script setup lang="ts">
import { computed } from 'vue';

interface Props {
  order: Order;
}

const props = defineProps<Props>();

// ä½¿ç”¨computedé¿å…é‡å¤è®¡ç®—
const formattedAmount = computed(() => {
  return new Intl.NumberFormat('zh-CN', {
    style: 'currency',
    currency: 'CNY'
  }).format(props.order.totalAmount);
});

const statusColor = computed(() => {
  const colors = {
    pending: 'warning',
    preparing: 'info',
    ready: 'success',
    completed: 'success',
    cancelled: 'danger'
  };
  return colors[props.order.status] || 'default';
});

// ä½¿ç”¨shallowRefä¼˜åŒ–å¤§å¯¹è±¡
const orderRef = shallowRef(props.order);

// ä½¿ç”¨v-onceä¼˜åŒ–é™æ€å†…å®¹
</script>
```

---

## ğŸš€ APIä¼˜åŒ–æ–¹æ¡ˆ

### 1. å“åº”ä¼˜åŒ–

```typescript
// middleware/responseOptimization.ts
import compression from 'compression';
import helmet from 'helmet';

// Gzipå‹ç¼©
export const compressionMiddleware = compression({
  level: 6,
  threshold: 1024
});

// å®‰å…¨å¤´
export const securityMiddleware = helmet({
  hsts: {
    maxAge: 31536000,
    includeSubDomains: true,
    preload: true
  },
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "https:"]
    }
  }
});

// å“åº”æ—¶é—´ä¸­é—´ä»¶
export const responseTimeMiddleware = (req: Request, res: Response, next: NextFunction) => {
  const start = Date.now();
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`[Response] ${req.method} ${req.url} - ${duration}ms`);
  });
  
  next();
};
```

### 2. å¹¶å‘æ§åˆ¶

```typescript
// utils/requestQueue.ts
import PQueue from 'p-queue';

class RequestQueue {
  private queue: PQueue;
  
  constructor(concurrency: number = 10) {
    this.queue = new PQueue({
      concurrency,
      timeout: 30000,
      throwOnTimeout: true
    });
  }
  
  async add<T>(task: () => Promise<T>): Promise<T> {
    return this.queue.add(task);
  }
  
  async addAll<T>(tasks: Array<() => Promise<T>>): Promise<T[]> {
    return this.queue.addAll(tasks);
  }
  
  get size(): number {
    return this.queue.size;
  }
  
  get pending(): number {
    return this.queue.pending;
  }
}

export const apiQueue = new RequestQueue(10);
export const dbQueue = new RequestQueue(5);

// ä½¿ç”¨ç¤ºä¾‹
const result = await apiQueue.add(() => api.getOrders());
```

### 3. è¯·æ±‚åˆå¹¶

```typescript
// utils/requestBatcher.ts
class RequestBatcher<T, R> {
  private queue: Array<{ data: T; resolve: (value: R) => void }> = [];
  private timer: NodeJS.Timeout | null = null;
  private batchSize: number;
  private batchDelay: number;
  private batchFn: (data: T[]) => Promise<R[]>;
  
  constructor(
    batchFn: (data: T[]) => Promise<R[]>,
    options: {
      batchSize?: number;
      batchDelay?: number;
    } = {}
  ) {
    this.batchFn = batchFn;
    this.batchSize = options.batchSize || 10;
    this.batchDelay = options.batchDelay || 100;
  }
  
  async add(data: T): Promise<R> {
    return new Promise((resolve) => {
      this.queue.push({ data, resolve });
      
      if (this.queue.length >= this.batchSize) {
        this.flush();
      } else if (!this.timer) {
        this.timer = setTimeout(() => this.flush(), this.batchDelay);
      }
    });
  }
  
  private async flush(): Promise<void> {
    if (this.timer) {
      clearTimeout(this.timer);
      this.timer = null;
    }
    
    if (this.queue.length === 0) return;
    
    const batch = this.queue.splice(0, this.batchSize);
    const data = batch.map(item => item.data);
    
    try {
      const results = await this.batchFn(data);
      batch.forEach((item, index) => {
        item.resolve(results[index]);
      });
    } catch (error) {
      batch.forEach(item => {
        item.reject(error);
      });
    }
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const customerBatcher = new RequestBatcher(
  async (customerIds: string[]) => {
    return await api.getCustomersByIds(customerIds);
  },
  { batchSize: 20, batchDelay: 50 }
);

const customer = await customerBatcher.add('customer-123');
```

---

## ğŸ“Š æ€§èƒ½ç›‘æ§

### 1. APMç›‘æ§

```typescript
// monitoring/apm.ts
import { createLogger } from 'winston';

const logger = createLogger({
  level: 'info',
  format: winston.format.json(),
  transports: [
    new winston.transports.Console(),
    new winston.transports.File({ filename: 'apm.log' })
  ]
});

export class APM {
  static trackRequest(req: Request, res: Response, next: NextFunction) {
    const start = Date.now();
    const requestId = req.id || generateId();
    
    req.apm = {
      requestId,
      startTime: start,
      metadata: {
        method: req.method,
        url: req.url,
        userAgent: req.headers['user-agent'],
        ip: req.ip
      }
    };
    
    res.on('finish', () => {
      const duration = Date.now() - start;
      const statusCode = res.statusCode;
      
      logger.info('request_completed', {
        requestId,
        duration,
        statusCode,
        ...req.apm.metadata
      });
      
      // å‘é€åˆ°APMæœåŠ¡
      this.sendToAPM({
        requestId,
        duration,
        statusCode,
        ...req.apm.metadata
      });
    });
    
    next();
  }
  
  static trackError(error: Error, req?: Request) {
    logger.error('error_occurred', {
      message: error.message,
      stack: error.stack,
      requestId: req?.apm?.requestId,
      ...req?.apm?.metadata
    });
    
    // å‘é€åˆ°é”™è¯¯è¿½è¸ªæœåŠ¡
    this.sendToSentry(error, req);
  }
  
  private static sendToAPM(data: any) {
    // å‘é€åˆ°New Relicã€Datadogç­‰APMæœåŠ¡
  }
  
  private static sendToSentry(error: Error, req?: Request) {
    // å‘é€åˆ°Sentryç­‰é”™è¯¯è¿½è¸ªæœåŠ¡
  }
}
```

### 2. æ€§èƒ½æŒ‡æ ‡

```typescript
// monitoring/metrics.ts
import { Counter, Histogram, Registry } from 'prom-client';

const register = new Registry();

// è¯·æ±‚è®¡æ•°å™¨
export const requestCounter = new Counter({
  name: 'http_requests_total',
  help: 'Total number of HTTP requests',
  labelNames: ['method', 'route', 'status_code'],
  registers: [register]
});

// è¯·æ±‚å»¶è¿Ÿ
export const requestDuration = new Histogram({
  name: 'http_request_duration_seconds',
  help: 'HTTP request duration in seconds',
  labelNames: ['method', 'route'],
  buckets: [0.1, 0.5, 1, 2, 5, 10],
  registers: [register]
});

// æ•°æ®åº“æŸ¥è¯¢å»¶è¿Ÿ
export const dbQueryDuration = new Histogram({
  name: 'db_query_duration_seconds',
  help: 'Database query duration in seconds',
  labelNames: ['operation', 'table'],
  buckets: [0.01, 0.05, 0.1, 0.5, 1, 5],
  registers: [register]
});

// ç¼“å­˜å‘½ä¸­ç‡
export const cacheHitRate = new Counter({
  name: 'cache_hits_total',
  help: 'Total number of cache hits',
  labelNames: ['cache_type'],
  registers: [register]
});

export const cacheMissRate = new Counter({
  name: 'cache_misses_total',
  help: 'Total number of cache misses',
  labelNames: ['cache_type'],
  registers: [register]
});

// æš´éœ²æŒ‡æ ‡ç«¯ç‚¹
export function getMetrics() {
  return register.metrics();
}
```

---

## ğŸ“‹ å®æ–½è®¡åˆ’

### é˜¶æ®µ1ï¼šæ•°æ®åº“ä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

- [ ] åˆ›å»ºæ‰€æœ‰å¿…è¦çš„ç´¢å¼•
- [ ] ä¼˜åŒ–N+1æŸ¥è¯¢é—®é¢˜
- [ ] å®ç°è¿æ¥æ± ä¼˜åŒ–
- [ ] å®ç°Redisç¼“å­˜
- [ ] æ€§èƒ½æµ‹è¯•å’ŒéªŒè¯

### é˜¶æ®µ2ï¼šå‰ç«¯ä¼˜åŒ–ï¼ˆ2-3å‘¨ï¼‰

- [ ] å®ç°è·¯ç”±çº§ä»£ç åˆ†å‰²
- [ ] å®ç°ç»„ä»¶çº§ä»£ç åˆ†å‰²
- [ ] ä¼˜åŒ–å›¾ç‰‡èµ„æº
- [ ] å¯ç”¨Gzipå‹ç¼©
- [ ] å®ç°è™šæ‹Ÿæ»šåŠ¨
- [ ] æ€§èƒ½æµ‹è¯•å’ŒéªŒè¯

### é˜¶æ®µ3ï¼šAPIä¼˜åŒ–ï¼ˆ1-2å‘¨ï¼‰

- [ ] å®ç°å“åº”å‹ç¼©
- [ ] å®ç°å¹¶å‘æ§åˆ¶
- [ ] å®ç°è¯·æ±‚åˆå¹¶
- [ ] ä¼˜åŒ–å“åº”æ ¼å¼
- [ ] æ€§èƒ½æµ‹è¯•å’ŒéªŒè¯

### é˜¶æ®µ4ï¼šç›‘æ§å’Œä¼˜åŒ–ï¼ˆæŒç»­ï¼‰

- [ ] éƒ¨ç½²APMç›‘æ§
- [ ] å®ç°æ€§èƒ½æŒ‡æ ‡æ”¶é›†
- [ ] å»ºç«‹æ€§èƒ½åŸºå‡†
- [ ] æŒç»­ä¼˜åŒ–å’Œæ”¹è¿›

---

## ğŸ¯ é¢„æœŸæ•ˆæœ

### æ€§èƒ½æå‡

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| æ•°æ®åº“æŸ¥è¯¢æ—¶é—´ | 200ms | 100ms | 50% â†“ |
| APIå“åº”æ—¶é—´ | 150ms | 105ms | 30% â†“ |
| å‰ç«¯é¦–å±åŠ è½½ | 3s | 1.8s | 40% â†“ |
| ç³»ç»Ÿååé‡ | 1000 req/s | 2000 req/s | 100% â†‘ |

### èµ„æºä¼˜åŒ–

| æŒ‡æ ‡ | ä¼˜åŒ–å‰ | ä¼˜åŒ–å | æå‡å¹…åº¦ |
|------|--------|--------|----------|
| å›¾ç‰‡å¤§å° | 500KB | 100KB | 80% â†“ |
| JSåŒ…å¤§å° | 2MB | 1.2MB | 40% â†“ |
| CSSåŒ…å¤§å° | 500KB | 300KB | 40% â†“ |
| æ€»é¡µé¢å¤§å° | 3MB | 1.6MB | 47% â†“ |

---

## ğŸ”— ç›¸å…³æ–‡æ¡£

- [å®‰å…¨æ¼æ´ä¿®å¤æŠ¥å‘Š](./å®‰å…¨æ¼æ´ä¿®å¤æŠ¥å‘Š.md)
- [é›†æˆæµ‹è¯•æŠ¥å‘Š](./é›†æˆæµ‹è¯•æŠ¥å‘Š.md)
- [å•å…ƒæµ‹è¯•æŠ¥å‘Š](./å•å…ƒæµ‹è¯•æŠ¥å‘Š.md)
- [ç”¨æˆ·éªŒæ”¶æµ‹è¯•æŠ¥å‘Š](./ç”¨æˆ·éªŒæ”¶æµ‹è¯•æŠ¥å‘Š.md)

---

**æ–‡æ¡£åˆ›å»ºæ—¶é—´**: 2026-01-20 23:40:00  
**ä¸‹æ¬¡æ›´æ–°**: 2026-02-20ï¼ˆä¸€ä¸ªæœˆåï¼‰
