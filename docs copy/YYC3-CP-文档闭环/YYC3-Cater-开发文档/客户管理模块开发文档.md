# YYC³餐饮行业智能化平台 - 客户管理模块开发文档

## 文档信息

| 项目 | 内容 |
|------|------|
| 文档名称 | YYC³餐饮行业智能化平台客户管理模块开发文档 |
| 文档版本 | v1.0.0 |
| 创建日期 | 2026-01-20 |
| 最后更新 | 2026-01-20 |
| 文档状态 | 正式版 |

---

## 目录

1. [模块概述](#1-模块概述)
2. [技术架构](#2-技术架构)
3. [数据模型](#3-数据模型)
4. [API接口](#4-api接口)
5. [组件设计](#5-组件设计)
6. [核心功能](#6-核心功能)
7. [开发指南](#7-开发指南)
8. [测试指南](#8-测试指南)
9. [部署指南](#9-部署指南)
10. [常见问题](#10-常见问题)

---

## 1. 模块概述

### 1.1 模块简介

客户管理模块是YYC³餐饮行业智能化平台的核心模块之一，提供全方位的客户信息管理功能，包括客户基本信息管理、客户分群、客户标签、客户状态跟踪、客户历史查询、客户生命周期管理等功能。

### 1.2 核心功能

- **客户信息管理**：客户基本信息的增删改查
- **客户分群管理**：支持手动分群、自动分群、RFM分群、生命周期分群
- **客户标签管理**：为客户打标签，支持行为标签、偏好标签、自定义标签、系统标签
- **客户状态跟踪**：实时跟踪客户状态变化，记录状态历史
- **客户历史查询**：查询客户的订单历史、积分历史、状态历史、访问记录
- **客户生命周期管理**：基于RFM模型和规则引擎的自动生命周期管理
- **客户流失预测**：基于多种因素的客户流失预测
- **智能客户关怀**：基于规则的自动客户关怀提醒

### 1.3 技术栈

- **前端框架**：Vue 3 + TypeScript
- **UI组件库**：Element Plus
- **状态管理**：Pinia
- **HTTP客户端**：Axios
- **图表库**：ECharts
- **日期处理**：Day.js

---

## 2. 技术架构

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                   前端层 (Vue 3)                    │
├─────────────────────────────────────────────────────────┤
│  视图层 (Views)                                    │
│  - CustomerStatusTracker.vue                          │
│  - CustomerHistoryQuery.vue                          │
│  - CustomerGroupManagement.vue                        │
│  - CustomerLifecycleDashboard.vue                     │
├─────────────────────────────────────────────────────────┤
│  业务逻辑层 (Composables)                           │
│  - useLifecycleRuleEngine.ts                        │
│  - useRFMModel.ts                                  │
│  - useCareReminder.ts                              │
│  - useChurnPrediction.ts                           │
├─────────────────────────────────────────────────────────┤
│  数据访问层 (API)                                   │
│  - customer.ts                                      │
├─────────────────────────────────────────────────────────┤
│                   后端层 (Node.js)                   │
├─────────────────────────────────────────────────────────┤
│  控制器层 (Controllers)                            │
│  - CustomerController                               │
│  - CustomerGroupController                          │
│  - CustomerTagController                            │
│  - CustomerLifecycleController                      │
├─────────────────────────────────────────────────────────┤
│  服务层 (Services)                                 │
│  - CustomerService                                 │
│  - CustomerGroupService                            │
│  - CustomerLifecycleService                        │
│  - RFMAnalysisService                             │
│  - ChurnPredictionService                         │
├─────────────────────────────────────────────────────────┤
│  数据访问层 (Repositories)                          │
│  - CustomerRepository                              │
│  - CustomerGroupRepository                         │
│  - CustomerLifecycleRepository                    │
├─────────────────────────────────────────────────────────┤
│                   数据层 (PostgreSQL)                │
├─────────────────────────────────────────────────────────┤
│  - customers                                       │
│  - customer_groups                                 │
│  - customer_group_members                          │
│  - customer_tags                                  │
│  - customer_tag_relations                         │
│  - customer_lifecycle                             │
│  - lifecycle_stage_history                        │
│  - lifecycle_rules                               │
│  - rfm_scores                                    │
│  - care_reminders                                │
│  - churn_predictions                             │
└─────────────────────────────────────────────────────────┘
```

### 2.2 目录结构

```
frontend/apps/admin-dashboard/src/
├── api/
│   └── customer.ts                    # 客户管理API接口
├── composables/
│   ├── useLifecycleRuleEngine.ts       # 生命周期规则引擎
│   ├── useRFMModel.ts               # RFM客户价值评估模型
│   ├── useCareReminder.ts           # 智能客户关怀提醒
│   └── useChurnPrediction.ts        # 客户流失预测
├── views/
│   ├── CustomerStatusTracker.vue     # 客户状态跟踪组件
│   ├── CustomerHistoryQuery.vue      # 客户历史查询组件
│   ├── CustomerGroupManagement.vue   # 客户分群管理组件
│   └── CustomerLifecycleDashboard.vue  # 生命周期数据分析看板
└── types/
    └── customer.ts                  # 客户相关类型定义
```

---

## 3. 数据模型

### 3.1 客户表 (customers)

```sql
CREATE TABLE customers (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    phone VARCHAR(20) NOT NULL UNIQUE,
    email VARCHAR(100),
    gender VARCHAR(10) CHECK (gender IN ('male', 'female', 'other')),
    birthday DATE,
    avatar VARCHAR(255),
    member_level_id VARCHAR(36),
    points INT NOT NULL DEFAULT 0,
    total_spent DECIMAL(10,2) NOT NULL DEFAULT 0.00,
    total_orders INT NOT NULL DEFAULT 0,
    last_visit_at TIMESTAMP,
    last_order_at TIMESTAMP,
    status VARCHAR(20) NOT NULL DEFAULT 'active' CHECK (status IN ('active', 'inactive', 'blacklisted')),
    source VARCHAR(50),
    register_ip VARCHAR(50),
    register_device VARCHAR(100),
    metadata JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### 3.2 客户分群表 (customer_groups)

```sql
CREATE TABLE customer_groups (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    description TEXT,
    group_type VARCHAR(50) NOT NULL CHECK (group_type IN ('manual', 'auto', 'rfm', 'lifecycle')),
    conditions JSONB,
    color VARCHAR(20) DEFAULT '#409EFF',
    icon VARCHAR(50),
    priority INT NOT NULL DEFAULT 0,
    member_count INT NOT NULL DEFAULT 0,
    enabled BOOLEAN NOT NULL DEFAULT true,
    created_by VARCHAR(36),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### 3.3 客户标签表 (customer_tags)

```sql
CREATE TABLE customer_tags (
    id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(50) NOT NULL,
    description TEXT,
    color VARCHAR(20) DEFAULT '#67C23A',
    tag_type VARCHAR(50) NOT NULL CHECK (tag_type IN ('behavior', 'preference', 'custom', 'system')),
    usage_count INT NOT NULL DEFAULT 0,
    created_by VARCHAR(36),
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

### 3.4 客户生命周期表 (customer_lifecycle)

```sql
CREATE TABLE customer_lifecycle (
    id VARCHAR(36) PRIMARY KEY,
    customer_id VARCHAR(36) NOT NULL,
    current_stage VARCHAR(50) NOT NULL,
    previous_stage VARCHAR(50),
    stage_changed_at TIMESTAMP NOT NULL,
    days_in_current_stage INT NOT NULL DEFAULT 0,
    total_days_in_lifecycle INT NOT NULL DEFAULT 0,
    metadata JSONB,
    created_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE
);
```

### 3.5 RFM评分表 (rfm_scores)

```sql
CREATE TABLE rfm_scores (
    id VARCHAR(36) PRIMARY KEY,
    customer_id VARCHAR(36) NOT NULL,
    recency_score INT NOT NULL,
    frequency_score INT NOT NULL,
    monetary_score INT NOT NULL,
    rfm_score INT NOT NULL,
    customer_level VARCHAR(20) NOT NULL,
    calculated_at TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (customer_id) REFERENCES customers(id) ON DELETE CASCADE
);
```

---

## 4. API接口

### 4.1 客户管理接口

#### 4.1.1 获取客户列表

```typescript
GET /api/customers
```

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| keyword | string | 否 | 关键词搜索 |
| phone | string | 否 | 手机号 |
| email | string | 否 | 邮箱 |
| status | string | 否 | 状态 |
| page | number | 否 | 页码 |
| size | number | 否 | 每页数量 |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "data": [
      {
        "id": "xxx",
        "name": "张三",
        "phone": "13800138000",
        "email": "zhangsan@example.com",
        "status": "active",
        "totalSpent": 1000.00,
        "totalOrders": 10,
        "points": 500,
        "createdAt": "2026-01-01T00:00:00Z"
      }
    ],
    "total": 100
  }
}
```

#### 4.1.2 获取客户详情

```typescript
GET /api/customers/:id
```

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 客户ID |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "xxx",
    "name": "张三",
    "phone": "13800138000",
    "email": "zhangsan@example.com",
    "status": "active",
    "totalSpent": 1000.00,
    "totalOrders": 10,
    "points": 500,
    "createdAt": "2026-01-01T00:00:00Z"
  }
}
```

#### 4.1.3 创建客户

```typescript
POST /api/customers
```

**请求体**：

```json
{
  "name": "张三",
  "phone": "13800138000",
  "email": "zhangsan@example.com",
  "gender": "male",
  "birthday": "1990-01-01"
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "创建成功",
  "data": {
    "id": "xxx",
    "name": "张三",
    "phone": "13800138000",
    "email": "zhangsan@example.com",
    "status": "active",
    "createdAt": "2026-01-20T00:00:00Z"
  }
}
```

#### 4.1.4 更新客户

```typescript
PUT /api/customers/:id
```

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 客户ID |

**请求体**：

```json
{
  "name": "张三",
  "email": "zhangsan_new@example.com"
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "更新成功",
  "data": {
    "id": "xxx",
    "name": "张三",
    "email": "zhangsan_new@example.com"
  }
}
```

#### 4.1.5 删除客户

```typescript
DELETE /api/customers/:id
```

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 客户ID |

**响应示例**：

```json
{
  "code": 200,
  "message": "删除成功"
}
```

### 4.2 客户分群接口

#### 4.2.1 获取客户分群列表

```typescript
GET /api/customer-groups
```

**请求参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| groupType | string | 否 | 分群类型 |
| enabled | boolean | 否 | 是否启用 |
| page | number | 否 | 页码 |
| size | number | 否 | 每页数量 |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "data": [
      {
        "id": "xxx",
        "name": "高价值客户",
        "groupType": "rfm",
        "memberCount": 100,
        "enabled": true,
        "createdAt": "2026-01-01T00:00:00Z"
      }
    ],
    "total": 10
  }
}
```

#### 4.2.2 创建客户分群

```typescript
POST /api/customer-groups
```

**请求体**：

```json
{
  "name": "高价值客户",
  "description": "RFM评分大于等于4的客户",
  "groupType": "rfm",
  "color": "#409EFF",
  "priority": 1,
  "enabled": true
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "创建成功",
  "data": {
    "id": "xxx",
    "name": "高价值客户",
    "groupType": "rfm",
    "memberCount": 0,
    "enabled": true,
    "createdAt": "2026-01-20T00:00:00Z"
  }
}
```

### 4.3 客户生命周期接口

#### 4.3.1 获取客户生命周期信息

```typescript
GET /api/customers/:id/lifecycle
```

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 客户ID |

**响应示例**：

```json
{
  "code": 200,
  "message": "success",
  "data": {
    "id": "xxx",
    "customerId": "xxx",
    "currentStage": "active",
    "previousStage": "new",
    "stageChangedAt": "2026-01-15T00:00:00Z",
    "daysInCurrentStage": 5,
    "totalDaysInLifecycle": 30
  }
}
```

#### 4.3.2 更新客户生命周期阶段

```typescript
PUT /api/customers/:id/lifecycle/stage
```

**路径参数**：

| 参数名 | 类型 | 必填 | 说明 |
|--------|------|------|------|
| id | string | 是 | 客户ID |

**请求体**：

```json
{
  "stage": "loyal",
  "reason": "客户消费频次和金额达到忠诚客户标准"
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "更新成功",
  "data": {
    "id": "xxx",
    "currentStage": "loyal",
    "stageChangedAt": "2026-01-20T00:00:00Z"
  }
}
```

### 4.4 RFM分析接口

#### 4.4.1 计算客户RFM评分

```typescript
POST /api/rfm/calculate
```

**请求体**：

```json
{
  "customerIds": ["xxx", "yyy"]
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "计算成功",
  "data": [
    {
      "customerId": "xxx",
      "recencyScore": 5,
      "frequencyScore": 4,
      "monetaryScore": 5,
      "rfmScore": 14,
      "customerLevel": "超级VIP"
    }
  ]
}
```

### 4.5 流失预测接口

#### 4.5.1 预测客户流失

```typescript
POST /api/churn-predictions/predict
```

**请求体**：

```json
{
  "customerIds": ["xxx", "yyy"]
}
```

**响应示例**：

```json
{
  "code": 200,
  "message": "预测成功",
  "data": [
    {
      "customerId": "xxx",
      "customerName": "张三",
      "churnProbability": 0.75,
      "riskLevel": "high",
      "riskFactors": ["60天未消费", "消费频次下降50%"],
      "predictedChurnDate": "2026-03-20T00:00:00Z"
    }
  ]
}
```

---

## 5. 组件设计

### 5.1 CustomerStatusTracker.vue

#### 5.1.1 组件说明

客户状态跟踪组件，用于实时监控客户状态变化，支持状态修改和历史查询。

#### 5.1.2 主要功能

- 状态统计展示
- 客户列表查询
- 客户状态修改
- 客户状态历史查询

#### 5.1.3 组件结构

```vue
<template>
  <div class="customer-status-tracker">
    <!-- 状态统计卡片 -->
    <el-card class="status-card">
      <div class="status-overview">
        <div class="status-item active">
          <div class="status-count">{{ statistics.active }}</div>
          <div class="status-label">活跃客户</div>
        </div>
        <!-- 其他状态统计 -->
      </div>
    </el-card>

    <!-- 筛选条件 -->
    <el-card class="filter-card">
      <el-form :model="filters" inline>
        <!-- 筛选表单 -->
      </el-form>
    </el-card>

    <!-- 客户列表 -->
    <el-card class="table-card">
      <el-table :data="customerList">
        <!-- 表格列 -->
      </el-table>
    </el-card>

    <!-- 状态修改对话框 -->
    <el-dialog v-model="statusDialogVisible">
      <!-- 状态修改表单 -->
    </el-dialog>

    <!-- 状态历史对话框 -->
    <el-dialog v-model="historyDialogVisible">
      <!-- 状态历史表格 -->
    </el-dialog>
  </div>
</template>
```

#### 5.1.4 核心方法

```typescript
const loadStatistics = async () => {
  const data = await getCustomerStatistics()
  Object.assign(statistics, data)
}

const loadCustomerList = async () => {
  const result = await getCustomers(params)
  customerList.value = result.data
  pagination.total = result.total
}

const handleChangeStatus = (row: Customer) => {
  statusForm.customerId = row.id
  statusForm.currentStatus = row.status
  statusDialogVisible.value = true
}

const handleStatusSubmit = async () => {
  await updateCustomerStatus(statusForm.customerId, statusForm.newStatus)
  ElMessage.success('状态修改成功')
  refreshData()
}
```

### 5.2 CustomerHistoryQuery.vue

#### 5.2.1 组件说明

客户历史查询组件，用于查询客户的订单历史、积分历史、状态历史、访问记录等。

#### 5.2.2 主要功能

- 客户基本信息展示
- 订单历史查询
- 积分历史查询
- 状态历史查询
- 访问记录查询

#### 5.2.3 组件结构

```vue
<template>
  <div class="customer-history-query">
    <!-- 客户信息卡片 -->
    <el-card class="customer-info-card">
      <div class="customer-info">
        <!-- 客户基本信息 -->
      </div>
    </el-card>

    <!-- 历史记录标签页 -->
    <el-card class="history-tabs-card">
      <el-tabs v-model="activeTab">
        <el-tab-pane label="订单历史" name="orders">
          <!-- 订单历史表格 -->
        </el-tab-pane>
        <el-tab-pane label="积分历史" name="points">
          <!-- 积分历史表格 -->
        </el-tab-pane>
        <el-tab-pane label="状态历史" name="status">
          <!-- 状态历史表格 -->
        </el-tab-pane>
        <el-tab-pane label="访问记录" name="visits">
          <!-- 访问记录表格 -->
        </el-tab-pane>
      </el-tabs>
    </el-card>
  </div>
</template>
```

### 5.3 CustomerGroupManagement.vue

#### 5.3.1 组件说明

客户分群管理组件，用于管理客户分群，支持创建、编辑、删除分群，以及分群成员管理。

#### 5.3.2 主要功能

- 分群统计展示
- 分群列表管理
- 分群创建和编辑
- 分群成员管理
- 批量添加和移除成员

#### 5.3.3 组件结构

```vue
<template>
  <div class="customer-group-management">
    <!-- 统计卡片 -->
    <el-card class="statistics-card">
      <div class="statistics-overview">
        <!-- 统计数据 -->
      </div>
    </el-card>

    <!-- 筛选条件 -->
    <el-card class="filter-card">
      <el-form :model="filters" inline>
        <!-- 筛选表单 -->
      </el-form>
    </el-card>

    <!-- 分群列表 -->
    <el-card class="table-card">
      <el-table :data="groupList">
        <!-- 表格列 -->
      </el-table>
    </el-card>

    <!-- 分群编辑对话框 -->
    <el-dialog v-model="groupDialogVisible">
      <!-- 分群表单 -->
    </el-dialog>

    <!-- 分群成员管理对话框 -->
    <el-dialog v-model="membersDialogVisible">
      <!-- 成员列表 -->
    </el-dialog>
  </div>
</template>
```

### 5.4 CustomerLifecycleDashboard.vue

#### 5.4.1 组件说明

客户生命周期数据分析看板，用于展示客户生命周期相关的数据分析和可视化图表。

#### 5.4.2 主要功能

- 生命周期阶段分布
- 客户价值分布（RFM）
- 生命周期流转趋势
- 客户留存率趋势
- 客户生命周期价值分布
- 流失预警管理
- 关怀提醒管理

#### 5.4.3 组件结构

```vue
<template>
  <div class="customer-lifecycle-dashboard">
    <!-- 头部操作栏 -->
    <div class="dashboard-header">
      <h1>客户生命周期管理看板</h1>
      <div class="header-actions">
        <!-- 操作按钮 -->
      </div>
    </div>

    <!-- 概览指标 -->
    <el-row :gutter="20" class="metrics-row">
      <el-col :span="4" v-for="metric in overviewMetrics">
        <el-card class="metric-card">
          <!-- 指标卡片 -->
        </el-card>
      </el-col>
    </el-row>

    <!-- 图表区域 -->
    <el-row :gutter="20" class="charts-row">
      <el-col :span="12">
        <el-card class="chart-card">
          <!-- 生命周期阶段分布图 -->
        </el-card>
      </el-col>
      <el-col :span="12">
        <el-card class="chart-card">
          <!-- 客户价值分布图 -->
        </el-card>
      </el-col>
    </el-row>

    <!-- 流失预警和关怀提醒 -->
    <el-row :gutter="20" class="alerts-row">
      <el-col :span="12">
        <el-card class="alert-card">
          <!-- 流失预警列表 -->
        </el-card>
      </el-col>
      <el-col :span="12">
        <el-card class="alert-card">
          <!-- 关怀提醒列表 -->
        </el-card>
      </el-col>
    </el-row>
  </div>
</template>
```

---

## 6. 核心功能

### 6.1 客户生命周期管理

#### 6.1.1 生命周期阶段定义

```typescript
export const LIFECYCLE_STAGES = {
  POTENTIAL: 'potential',
  NEW: 'new',
  ACTIVE: 'active',
  LOYAL: 'loyal',
  DORMANT: 'dormant',
  CHURNED: 'churned'
} as const

export const LIFECYCLE_STAGE_NAMES = {
  [LIFECYCLE_STAGES.POTENTIAL]: '潜在客户',
  [LIFECYCLE_STAGES.NEW]: '新客户',
  [LIFECYCLE_STAGES.ACTIVE]: '活跃客户',
  [LIFECYCLE_STAGES.LOYAL]: '忠诚客户',
  [LIFECYCLE_STAGES.DORMANT]: '休眠客户',
  [LIFECYCLE_STAGES.CHURNED]: '流失客户'
} as const
```

#### 6.1.2 生命周期规则引擎

##### 6.1.2.1 规则引擎架构

生命周期规则引擎采用事件驱动架构，基于客户行为事件自动评估和更新客户生命周期阶段。

```typescript
interface LifecycleRule {
  id: string
  name: string
  description: string
  triggerType: 'event' | 'time' | 'manual'
  triggerCondition: any
  fromStages: string[]
  toStage: string
  priority: number
  enabled: boolean
}

interface LifecycleTransition {
  customerId: string
  fromStage: string
  toStage: string
  reason: string
  triggeredBy: 'system' | 'manual'
  triggeredAt: Date
}
```

##### 6.1.2.2 规则引擎实现

```typescript
class LifecycleRuleEngine {
  private rules: LifecycleRule[] = []
  private eventBus: EventBus

  constructor() {
    this.initializeRules()
    this.setupEventListeners()
  }

  private initializeRules() {
    this.rules = [
      {
        id: 'rule-001',
        name: '首次下单转化',
        description: '客户首次下单时从潜在客户转化为新客户',
        triggerType: 'event',
        triggerCondition: { eventType: 'order.created', isFirstOrder: true },
        fromStages: [LIFECYCLE_STAGES.POTENTIAL],
        toStage: LIFECYCLE_STAGES.NEW,
        priority: 1,
        enabled: true
      },
      {
        id: 'rule-002',
        name: '活跃客户转化',
        description: '新客户30天内多次消费转化为活跃客户',
        triggerType: 'event',
        triggerCondition: { eventType: 'order.created', daysSinceFirstOrder: 30 },
        fromStages: [LIFECYCLE_STAGES.NEW],
        toStage: LIFECYCLE_STAGES.ACTIVE,
        priority: 2,
        enabled: true
      },
      {
        id: 'rule-003',
        name: '忠诚客户转化',
        description: '高价值高频次客户转化为忠诚客户',
        triggerType: 'event',
        triggerCondition: { eventType: 'order.created', rfmScore: 13 },
        fromStages: [LIFECYCLE_STAGES.ACTIVE],
        toStage: LIFECYCLE_STAGES.LOYAL,
        priority: 3,
        enabled: true
      },
      {
        id: 'rule-004',
        name: '休眠客户转化',
        description: '60天未消费转化为休眠客户',
        triggerType: 'time',
        triggerCondition: { daysSinceLastOrder: 60 },
        fromStages: [LIFECYCLE_STAGES.ACTIVE, LIFECYCLE_STAGES.LOYAL],
        toStage: LIFECYCLE_STAGES.DORMANT,
        priority: 4,
        enabled: true
      },
      {
        id: 'rule-005',
        name: '流失客户转化',
        description: '90天未消费转化为流失客户',
        triggerType: 'time',
        triggerCondition: { daysSinceLastOrder: 90 },
        fromStages: [LIFECYCLE_STAGES.DORMANT],
        toStage: LIFECYCLE_STAGES.CHURNED,
        priority: 5,
        enabled: true
      },
      {
        id: 'rule-006',
        name: '休眠客户激活',
        description: '休眠客户再次消费转化为活跃客户',
        triggerType: 'event',
        triggerCondition: { eventType: 'order.created' },
        fromStages: [LIFECYCLE_STAGES.DORMANT, LIFECYCLE_STAGES.CHURNED],
        toStage: LIFECYCLE_STAGES.ACTIVE,
        priority: 6,
        enabled: true
      }
    ]
  }

  private setupEventListeners() {
    this.eventBus.on('order.created', this.handleOrderCreated.bind(this))
    this.eventBus.on('customer.registered', this.handleCustomerRegistered.bind(this))
    this.eventBus.on('time.check', this.handleTimeCheck.bind(this))
  }

  async handleOrderCreated(event: OrderCreatedEvent) {
    const customer = await this.customerService.getCustomer(event.customerId)
    const lifecycle = await this.lifecycleService.getLifecycle(customer.id)

    const applicableRules = this.rules.filter(rule =>
      rule.enabled &&
      rule.fromStages.includes(lifecycle.currentStage) &&
      this.checkTriggerCondition(rule, event, customer, lifecycle)
    )

    if (applicableRules.length > 0) {
      const rule = applicableRules.sort((a, b) => a.priority - b.priority)[0]
      await this.executeTransition(customer, lifecycle, rule, 'system')
    }
  }

  async handleTimeCheck() {
    const customers = await this.customerService.getAllCustomers()

    for (const customer of customers) {
      const lifecycle = await this.lifecycleService.getLifecycle(customer.id)

      const applicableRules = this.rules.filter(rule =>
        rule.enabled &&
        rule.triggerType === 'time' &&
        rule.fromStages.includes(lifecycle.currentStage) &&
        this.checkTimeCondition(rule, customer, lifecycle)
      )

      if (applicableRules.length > 0) {
        const rule = applicableRules.sort((a, b) => a.priority - b.priority)[0]
        await this.executeTransition(customer, lifecycle, rule, 'system')
      }
    }
  }

  private checkTriggerCondition(
    rule: LifecycleRule,
    event: any,
    customer: Customer,
    lifecycle: Lifecycle
  ): boolean {
    const condition = rule.triggerCondition

    if (condition.eventType !== event.type) {
      return false
    }

    if (condition.isFirstOrder && !event.isFirstOrder) {
      return false
    }

    if (condition.daysSinceFirstOrder) {
      const daysSinceFirstOrder = this.getDaysSince(customer.firstOrderAt)
      if (daysSinceFirstOrder > condition.daysSinceFirstOrder) {
        return false
      }
    }

    if (condition.rfmScore) {
      const rfmScore = await this.rfmService.getLatestRFMScore(customer.id)
      if (!rfmScore || rfmScore.rfmScore < condition.rfmScore) {
        return false
      }
    }

    return true
  }

  private checkTimeCondition(
    rule: LifecycleRule,
    customer: Customer,
    lifecycle: Lifecycle
  ): boolean {
    const condition = rule.triggerCondition

    if (condition.daysSinceLastOrder) {
      const daysSinceLastOrder = this.getDaysSince(customer.lastOrderAt)
      return daysSinceLastOrder >= condition.daysSinceLastOrder
    }

    return false
  }

  private async executeTransition(
    customer: Customer,
    lifecycle: Lifecycle,
    rule: LifecycleRule,
    triggeredBy: 'system' | 'manual'
  ) {
    const transition: LifecycleTransition = {
      customerId: customer.id,
      fromStage: lifecycle.currentStage,
      toStage: rule.toStage,
      reason: rule.name,
      triggeredBy,
      triggeredAt: new Date()
    }

    await this.lifecycleService.updateLifecycleStage(
      customer.id,
      rule.toStage,
      rule.name
    )

    await this.eventBus.emit('lifecycle.transition', transition)
  }

  async manualTransition(customerId: string, toStage: string, reason: string) {
    const customer = await this.customerService.getCustomer(customerId)
    const lifecycle = await this.lifecycleService.getLifecycle(customerId)

    await this.executeTransition(customer, lifecycle, {
      id: 'manual',
      name: reason,
      description: reason,
      triggerType: 'manual',
      triggerCondition: {},
      fromStages: [lifecycle.currentStage],
      toStage,
      priority: 0,
      enabled: true
    }, 'manual')
  }
}
```

#### 6.1.3 阶段转换规则

```typescript
export const STAGE_TRANSITION_RULES = [
  {
    from: [LIFECYCLE_STAGES.POTENTIAL],
    to: LIFECYCLE_STAGES.NEW,
    condition: (customer: Customer) => {
      return customer.totalOrders > 0
    },
    reason: '首次下单'
  },
  {
    from: [LIFECYCLE_STAGES.NEW],
    to: LIFECYCLE_STAGES.ACTIVE,
    condition: (customer: Customer) => {
      const daysSinceFirstOrder = getDaysSince(customer.firstOrderAt)
      return daysSinceFirstOrder <= 30 && customer.totalOrders >= 2
    },
    reason: '30天内多次消费'
  },
  {
    from: [LIFECYCLE_STAGES.ACTIVE],
    to: LIFECYCLE_STAGES.LOYAL,
    condition: (customer: Customer) => {
      return customer.totalSpent >= 5000 && customer.totalOrders >= 10
    },
    reason: '高价值高频次消费'
  },
  {
    from: [LIFECYCLE_STAGES.ACTIVE, LIFECYCLE_STAGES.LOYAL],
    to: LIFECYCLE_STAGES.DORMANT,
    condition: (customer: Customer) => {
      const daysSinceLastOrder = getDaysSince(customer.lastOrderAt)
      return daysSinceLastOrder >= 60
    },
    reason: '60天未消费'
  },
  {
    from: [LIFECYCLE_STAGES.DORMANT],
    to: LIFECYCLE_STAGES.CHURNED,
    condition: (customer: Customer) => {
      const daysSinceLastOrder = getDaysSince(customer.lastOrderAt)
      return daysSinceLastOrder >= 90
    },
    reason: '90天未消费'
  },
  {
    from: [LIFECYCLE_STAGES.DORMANT, LIFECYCLE_STAGES.CHURNED],
    to: LIFECYCLE_STAGES.ACTIVE,
    condition: (customer: Customer) => {
      const daysSinceLastOrder = getDaysSince(customer.lastOrderAt)
      return daysSinceLastOrder < 30
    },
    reason: '重新激活'
  }
]
```

#### 6.1.4 生命周期数据看板

生命周期数据看板提供多维度的数据分析和可视化展示：

```typescript
interface LifecycleDashboardData {
  overview: {
    totalCustomers: number
    potentialCustomers: number
    newCustomers: number
    activeCustomers: number
    loyalCustomers: number
    dormantCustomers: number
    churnedCustomers: number
  }
  stageDistribution: {
    stage: string
    count: number
    percentage: number
  }[]
  flowTrend: {
    date: string
    potentialToNew: number
    newToActive: number
    activeToLoyal: number
    loyalToDormant: number
    dormantToChurned: number
    churnedToActive: number
  }[]
  retentionTrend: {
    date: string
    newCustomers: number
    retentionRate: number
    retentionCount: number
    churnCount: number
  }[]
  clvDistribution: {
    range: string
    count: number
    percentage: number
  }[]
  averageCLV: number
  totalCLV: number
}
```

### 6.2 RFM客户价值评估

#### 6.2.1 RFM评分计算

```typescript
class RFMModel {
  private recencyWeights = { 7: 5, 14: 4, 30: 3, 60: 2, 90: 1 }
  private frequencyWeights = { 20: 5, 10: 4, 5: 3, 2: 2, 1: 1 }
  private monetaryWeights = { 5000: 5, 2000: 4, 1000: 3, 500: 2, 0: 1 }

  async calculateRFMScore(customer: Customer): Promise<RFMScore> {
    const recencyScore = this.calculateRecencyScore(customer.lastOrderAt)
    const frequencyScore = this.calculateFrequencyScore(customer.totalOrders)
    const monetaryScore = this.calculateMonetaryScore(customer.totalSpent)

    const rfmScore = recencyScore + frequencyScore + monetaryScore
    const customerLevel = this.getCustomerLevel(rfmScore)

    const rfmData: RFMScore = {
      id: generateId(),
      customerId: customer.id,
      recencyScore,
      frequencyScore,
      monetaryScore,
      rfmScore,
      customerLevel,
      calculatedAt: new Date()
    }

    await this.rfmRepository.save(rfmData)
    return rfmData
  }

  async batchCalculateRFMScores(customerIds: string[]): Promise<RFMScore[]> {
    const results: RFMScore[] = []

    for (const customerId of customerIds) {
      const customer = await this.customerRepository.findById(customerId)
      if (customer) {
        const rfmScore = await this.calculateRFMScore(customer)
        results.push(rfmScore)
      }
    }

    return results
  }

  private calculateRecencyScore(lastOrderAt: Date | null): number {
    if (!lastOrderAt) return 1

    const daysSinceLastOrder = this.getDaysSince(lastOrderAt)

    for (const [days, score] of Object.entries(this.recencyWeights)) {
      if (daysSinceLastOrder <= parseInt(days)) {
        return score
      }
    }

    return 1
  }

  private calculateFrequencyScore(totalOrders: number): number {
    for (const [orders, score] of Object.entries(this.frequencyWeights)) {
      if (totalOrders >= parseInt(orders)) {
        return score
      }
    }

    return 1
  }

  private calculateMonetaryScore(totalSpent: number): number {
    for (const [amount, score] of Object.entries(this.monetaryWeights)) {
      if (totalSpent >= parseInt(amount)) {
        return score
      }
    }

    return 1
  }

  private getCustomerLevel(rfmScore: number): string {
    if (rfmScore >= 13) return '超级VIP'
    if (rfmScore >= 10) return 'VIP'
    if (rfmScore >= 7) return '会员'
    if (rfmScore >= 4) return '普通'
    return '低价值'
  }

  async getRFMStatistics(startDate?: Date, endDate?: Date): Promise<RFMStatistics> {
    const rfmScores = await this.rfmRepository.findByDateRange(startDate, endDate)

    const totalCustomers = rfmScores.length
    const averageRFMScore = rfmScores.reduce((sum, rfm) => sum + rfm.rfmScore, 0) / totalCustomers

    const customerLevelDistribution = this.calculateLevelDistribution(rfmScores)
    const recencyDistribution = this.calculateScoreDistribution(rfmScores, 'recencyScore')
    const frequencyDistribution = this.calculateScoreDistribution(rfmScores, 'frequencyScore')
    const monetaryDistribution = this.calculateScoreDistribution(rfmScores, 'monetaryScore')

    return {
      totalCustomers,
      averageRFMScore,
      customerLevelDistribution,
      recencyDistribution,
      frequencyDistribution,
      monetaryDistribution
    }
  }

  private calculateLevelDistribution(rfmScores: RFMScore[]): any[] {
    const levels = ['超级VIP', 'VIP', '会员', '普通', '低价值']
    const distribution = levels.map(level => {
      const count = rfmScores.filter(rfm => rfm.customerLevel === level).length
      return {
        level,
        count,
        percentage: (count / rfmScores.length) * 100
      }
    })

    return distribution
  }

  private calculateScoreDistribution(rfmScores: RFMScore[], scoreField: string): any[] {
    const distribution = []

    for (let score = 5; score >= 1; score--) {
      const count = rfmScores.filter(rfm => rfm[scoreField] === score).length
      distribution.push({
        score,
        count,
        percentage: (count / rfmScores.length) * 100
      })
    }

    return distribution
  }
}
```

### 6.3 客户流失预测

#### 6.3.1 流失风险因素

```typescript
interface ChurnRiskFactor {
  factor: string
  weight: number
  threshold: number
}

class ChurnPredictionModel {
  private riskFactors: ChurnRiskFactor[] = [
    { factor: '30天未消费', weight: 0.2, threshold: 30 },
    { factor: '60天未消费', weight: 0.3, threshold: 60 },
    { factor: '90天未消费', weight: 0.4, threshold: 90 },
    { factor: '消费频次下降50%', weight: 0.25, threshold: -0.5 },
    { factor: '消费金额下降50%', weight: 0.15, threshold: -0.5 },
    { factor: '满意度评分低于3.5', weight: 0.1, threshold: 3.5 }
  ]

  async predictChurn(customer: Customer): Promise<ChurnPrediction> {
    const riskFactors: string[] = []
    let churnProbability = 0

    const daysSinceLastOrder = this.getDaysSince(customer.lastOrderAt)
    const frequencyDrop = await this.calculateFrequencyDrop(customer)
    const spendingDrop = await this.calculateSpendingDrop(customer)
    const satisfactionScore = await this.getSatisfactionScore(customer.id)

    if (daysSinceLastOrder >= 30) {
      churnProbability += 0.2
      riskFactors.push('30天未消费')
    }

    if (daysSinceLastOrder >= 60) {
      churnProbability += 0.3
      riskFactors.push('60天未消费')
    }

    if (daysSinceLastOrder >= 90) {
      churnProbability += 0.4
      riskFactors.push('90天未消费')
    }

    if (frequencyDrop <= -0.5) {
      churnProbability += 0.25
      riskFactors.push(`消费频次下降${Math.abs(frequencyDrop * 100).toFixed(0)}%`)
    }

    if (spendingDrop <= -0.5) {
      churnProbability += 0.15
      riskFactors.push(`消费金额下降${Math.abs(spendingDrop * 100).toFixed(0)}%`)
    }

    if (satisfactionScore < 3.5) {
      churnProbability += 0.1
      riskFactors.push(`满意度评分${satisfactionScore.toFixed(1)}分`)
    }

    churnProbability = Math.min(churnProbability, 1.0)

    const riskLevel = this.getRiskLevel(churnProbability)
    const predictedChurnDate = this.predictChurnDate(churnProbability, daysSinceLastOrder)
    const recommendations = this.generateRecommendations(riskFactors, riskLevel)

    const prediction: ChurnPrediction = {
      id: generateId(),
      customerId: customer.id,
      customerName: customer.name,
      customerPhone: customer.phone,
      customerEmail: customer.email,
      churnProbability: Math.round(churnProbability * 100) / 100,
      riskLevel,
      riskFactors,
      predictedChurnDate,
      recommendations,
      assignedTo: null,
      status: 'pending',
      createdAt: new Date(),
      updatedAt: new Date()
    }

    await this.churnRepository.save(prediction)
    return prediction
  }

  async batchPredictChurn(customerIds: string[]): Promise<ChurnPrediction[]> {
    const results: ChurnPrediction[] = []

    for (const customerId of customerIds) {
      const customer = await this.customerRepository.findById(customerId)
      if (customer) {
        const prediction = await this.predictChurn(customer)
        results.push(prediction)
      }
    }

    return results
  }

  private getRiskLevel(churnProbability: number): 'high' | 'medium' | 'low' {
    if (churnProbability >= 0.7) return 'high'
    if (churnProbability >= 0.4) return 'medium'
    return 'low'
  }

  private predictChurnDate(churnProbability: number, daysSinceLastOrder: number): Date {
    const daysToChurn = Math.ceil((1 - churnProbability) * 90)
    const predictedDate = new Date()
    predictedDate.setDate(predictedDate.getDate() + daysToChurn)
    return predictedDate
  }

  private generateRecommendations(riskFactors: string[], riskLevel: string): string[] {
    const recommendations: string[] = []

    if (riskFactors.includes('30天未消费')) {
      recommendations.push('发送关怀短信')
      recommendations.push('提供专属优惠券')
    }

    if (riskFactors.includes('60天未消费')) {
      recommendations.push('安排客户回访')
      recommendations.push('提供会员优惠')
    }

    if (riskFactors.includes('90天未消费')) {
      recommendations.push('立即联系客户了解情况')
      recommendations.push('提供专属优惠套餐')
    }

    if (riskFactors.some(f => f.includes('下降'))) {
      recommendations.push('了解客户需求变化')
      recommendations.push('优化产品和服务')
    }

    if (riskLevel === 'high') {
      recommendations.unshift('立即联系客户了解情况')
    }

    return [...new Set(recommendations)]
  }

  async getChurnStatistics(startDate?: Date, endDate?: Date): Promise<ChurnStatistics> {
    const predictions = await this.churnRepository.findByDateRange(startDate, endDate)

    const totalPredictions = predictions.length
    const highRiskCount = predictions.filter(p => p.riskLevel === 'high').length
    const mediumRiskCount = predictions.filter(p => p.riskLevel === 'medium').length
    const lowRiskCount = predictions.filter(p => p.riskLevel === 'low').length

    const pendingCount = predictions.filter(p => p.status === 'pending').length
    const inProgressCount = predictions.filter(p => p.status === 'in_progress').length
    const resolvedCount = predictions.filter(p => p.status === 'resolved').length
    const closedCount = predictions.filter(p => p.status === 'closed').length

    const averageChurnProbability = predictions.reduce((sum, p) => sum + p.churnProbability, 0) / totalPredictions

    const churnTrend = await this.calculateChurnTrend(startDate, endDate)

    return {
      totalPredictions,
      highRiskCount,
      mediumRiskCount,
      lowRiskCount,
      pendingCount,
      inProgressCount,
      resolvedCount,
      closedCount,
      averageChurnProbability,
      churnTrend
    }
  }

  private async calculateChurnTrend(startDate?: Date, endDate?: Date): Promise<any[]> {
    const predictions = await this.churnRepository.findByDateRange(startDate, endDate)
    const trendMap = new Map<string, any>()

    predictions.forEach(prediction => {
      const date = prediction.createdAt.toISOString().split('T')[0]

      if (!trendMap.has(date)) {
        trendMap.set(date, {
          date,
          highRiskCount: 0,
          mediumRiskCount: 0,
          lowRiskCount: 0,
          totalChurned: 0,
          churnRate: 0
        })
      }

      const trend = trendMap.get(date)
      trend.highRiskCount += prediction.riskLevel === 'high' ? 1 : 0
      trend.mediumRiskCount += prediction.riskLevel === 'medium' ? 1 : 0
      trend.lowRiskCount += prediction.riskLevel === 'low' ? 1 : 0
      trend.totalChurned += prediction.status === 'resolved' ? 1 : 0
    })

    const trend = Array.from(trendMap.values()).sort((a, b) => a.date.localeCompare(b.date))

    trend.forEach(t => {
      t.churnRate = t.totalChurned / (t.highRiskCount + t.mediumRiskCount + t.lowRiskCount)
    })

    return trend
  }
}
```

### 6.4 智能客户关怀

#### 6.4.1 关怀提醒生成

```typescript
interface CareReminderRule {
  id: string
  name: string
  description: string
  triggerType: 'time' | 'event'
  triggerCondition: any
  reminderType: string
  channel: 'sms' | 'email' | 'push'
  template: string
  priority: 'high' | 'medium' | 'low'
  enabled: boolean
}

class CareReminderEngine {
  private rules: CareReminderRule[] = []
  private eventBus: EventBus

  constructor() {
    this.initializeRules()
    this.setupEventListeners()
  }

  private initializeRules() {
    this.rules = [
      {
        id: 'rule-001',
        name: '7天未消费关怀',
        description: '客户7天未消费时发送关怀短信',
        triggerType: 'time',
        triggerCondition: { daysSinceLastOrder: 7 },
        reminderType: 'revisit',
        channel: 'sms',
        template: '亲爱的{name}，您已经{days}天没有光顾了，我们想念您！',
        priority: 'medium',
        enabled: true
      },
      {
        id: 'rule-002',
        name: '30天未消费关怀',
        description: '客户30天未消费时发送关怀短信和优惠券',
        triggerType: 'time',
        triggerCondition: { daysSinceLastOrder: 30 },
        reminderType: 'reactivation',
        channel: 'sms',
        template: '亲爱的{name}，您已经{days}天没有光顾了，特为您准备了一份专属优惠券！',
        priority: 'high',
        enabled: true
      },
      {
        id: 'rule-003',
        name: '生日关怀',
        description: '客户生日当天发送祝福',
        triggerType: 'time',
        triggerCondition: { isBirthday: true },
        reminderType: 'birthday',
        channel: 'sms',
        template: '亲爱的{name}，祝您生日快乐！特为您准备了生日专属优惠！',
        priority: 'high',
        enabled: true
      },
      {
        id: 'rule-004',
        name: '会员升级关怀',
        description: '客户等级提升时发送祝贺',
        triggerType: 'event',
        triggerCondition: { eventType: 'level.upgraded' },
        reminderType: 'upgrade',
        channel: 'sms',
        template: '亲爱的{name}，恭喜您升级为{level}会员！享受更多专属权益！',
        priority: 'medium',
        enabled: true
      },
      {
        id: 'rule-005',
        name: '消费后关怀',
        description: '客户消费后发送感谢',
        triggerType: 'event',
        triggerCondition: { eventType: 'order.completed' },
        reminderType: 'thankyou',
        channel: 'sms',
        template: '亲爱的{name}，感谢您的惠顾！期待您的再次光临！',
        priority: 'low',
        enabled: true
      }
    ]
  }

  private setupEventListeners() {
    this.eventBus.on('order.completed', this.handleOrderCompleted.bind(this))
    this.eventBus.on('level.upgraded', this.handleLevelUpgraded.bind(this))
    this.eventBus.on('time.check', this.handleTimeCheck.bind(this))
  }

  async handleOrderCompleted(event: OrderCompletedEvent) {
    const customer = await this.customerService.getCustomer(event.customerId)
    const applicableRules = this.rules.filter(rule =>
      rule.enabled &&
      rule.triggerType === 'event' &&
      rule.triggerCondition.eventType === 'order.completed'
    )

    for (const rule of applicableRules) {
      await this.createReminder(customer, rule)
    }
  }

  async handleLevelUpgraded(event: LevelUpgradedEvent) {
    const customer = await this.customerService.getCustomer(event.customerId)
    const applicableRules = this.rules.filter(rule =>
      rule.enabled &&
      rule.triggerType === 'event' &&
      rule.triggerCondition.eventType === 'level.upgraded'
    )

    for (const rule of applicableRules) {
      await this.createReminder(customer, rule, { level: event.newLevel })
    }
  }

  async handleTimeCheck() {
    const customers = await this.customerService.getAllCustomers()

    for (const customer of customers) {
      const applicableRules = this.rules.filter(rule =>
        rule.enabled &&
        rule.triggerType === 'time' &&
        this.checkTimeCondition(rule, customer)
      )

      for (const rule of applicableRules) {
        await this.createReminder(customer, rule)
      }
    }
  }

  private checkTimeCondition(rule: CareReminderRule, customer: Customer): boolean {
    const condition = rule.triggerCondition

    if (condition.daysSinceLastOrder) {
      const daysSinceLastOrder = this.getDaysSince(customer.lastOrderAt)
      return daysSinceLastOrder === condition.daysSinceLastOrder
    }

    if (condition.isBirthday) {
      const today = new Date()
      const birthday = new Date(customer.birthday)
      return today.getMonth() === birthday.getMonth() && today.getDate() === birthday.getDate()
    }

    return false
  }

  private async createReminder(
    customer: Customer,
    rule: CareReminderRule,
    variables?: any
  ): Promise<CareReminder> {
    const daysSinceLastOrder = this.getDaysSince(customer.lastOrderAt)
    const content = rule.template
      .replace('{name}', customer.name)
      .replace('{days}', daysSinceLastOrder.toString())
      .replace('{level}', variables?.level || '')

    const reminder: CareReminder = {
      id: generateId(),
      customerId: customer.id,
      customerName: customer.name,
      customerPhone: customer.phone,
      reminderType: rule.reminderType,
      title: rule.name,
      content,
      channel: rule.channel,
      priority: rule.priority,
      scheduledAt: new Date(),
      sentAt: null,
      status: 'pending',
      result: null,
      createdAt: new Date()
    }

    await this.reminderRepository.save(reminder)
    return reminder
  }

  async sendReminder(reminderId: string): Promise<CareReminder> {
    const reminder = await this.reminderRepository.findById(reminderId)

    if (!reminder) {
      throw new Error('提醒不存在')
    }

    const result = await this.sendChannelMessage(reminder)

    reminder.sentAt = new Date()
    reminder.status = 'sent'
    reminder.result = result

    await this.reminderRepository.save(reminder)
    return reminder
  }

  private async sendChannelMessage(reminder: CareReminder): Promise<any> {
    switch (reminder.channel) {
      case 'sms':
        return await this.smsService.send(reminder.customerPhone, reminder.content)
      case 'email':
        return await this.emailService.send(reminder.customerPhone, reminder.title, reminder.content)
      case 'push':
        return await this.pushService.send(reminder.customerId, reminder.title, reminder.content)
      default:
        throw new Error('不支持的发送渠道')
    }
  }

  async getReminderStatistics(startDate?: Date, endDate?: Date): Promise<CareReminderStatistics> {
    const reminders = await this.reminderRepository.findByDateRange(startDate, endDate)

    const totalReminders = reminders.length
    const pendingCount = reminders.filter(r => r.status === 'pending').length
    const sentCount = reminders.filter(r => r.status === 'sent').length
    const failedCount = reminders.filter(r => r.status === 'failed').length

    const highPriorityCount = reminders.filter(r => r.priority === 'high').length
    const mediumPriorityCount = reminders.filter(r => r.priority === 'medium').length
    const lowPriorityCount = reminders.filter(r => r.priority === 'low').length

    const topUsedTypes = this.calculateTopUsedTypes(reminders)

    return {
      totalReminders,
      pendingCount,
      sentCount,
      failedCount,
      highPriorityCount,
      mediumPriorityCount,
      lowPriorityCount,
      topUsedTypes
    }
  }

  private calculateTopUsedTypes(reminders: CareReminder[]): any[] {
    const typeMap = new Map<string, number>()

    reminders.forEach(reminder => {
      const count = typeMap.get(reminder.reminderType) || 0
      typeMap.set(reminder.reminderType, count + 1)
    })

    return Array.from(typeMap.entries())
      .map(([type, count]) => ({ type, count }))
      .sort((a, b) => b.count - a.count)
      .slice(0, 10)
  }
}
```

---

## 7. 开发指南

### 7.1 环境搭建

#### 7.1.1 前端环境

```bash
# 安装依赖
cd frontend/apps/admin-dashboard
npm install

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build
```

#### 7.1.2 后端环境

```bash
# 安装依赖
cd backend
npm install

# 启动开发服务器
npm run dev

# 构建生产版本
npm run build
```

### 7.2 代码规范

#### 7.2.1 命名规范

- **文件名**：使用kebab-case，如 `customer-status-tracker.vue`
- **组件名**：使用PascalCase，如 `CustomerStatusTracker`
- **变量名**：使用camelCase，如 `customerList`
- **常量名**：使用UPPER_SNAKE_CASE，如 `LIFECYCLE_STAGES`

#### 7.2.2 注释规范

```typescript
/**
 * @description 客户状态跟踪组件
 * @author YYC
 * @created 2026-01-20
 */
export const CustomerStatusTracker = defineComponent({
  // 组件实现
})
```

### 7.3 Git工作流

#### 7.3.1 分支策略

- `main`：主分支，用于生产环境
- `develop`：开发分支，用于集成开发
- `feature/*`：功能分支，用于开发新功能
- `bugfix/*`：修复分支，用于修复bug

#### 7.3.2 提交规范

```
feat: 添加客户分群管理功能
fix: 修复客户状态修改bug
docs: 更新API文档
style: 调整代码格式
refactor: 重构RFM计算逻辑
test: 添加客户管理模块测试
chore: 更新依赖包
```

### 7.4 调试技巧

#### 7.4.1 前端调试

1. 使用Chrome DevTools进行调试
2. 使用Vue DevTools查看组件状态
3. 使用console.log输出调试信息

#### 7.4.2 后端调试

1. 使用VS Code调试器
2. 使用Postman测试API接口
3. 查看服务器日志

---

## 8. 测试指南

### 8.1 单元测试

#### 8.1.1 测试框架

- **前端**：Vitest + Vue Test Utils
- **后端**：Jest

#### 8.1.2 测试示例

```typescript
describe('CustomerStatusTracker', () => {
  it('应该正确加载客户统计数据', async () => {
    const wrapper = mount(CustomerStatusTracker)
    await wrapper.vm.loadStatistics()
    expect(wrapper.vm.statistics.active).toBeGreaterThan(0)
  })

  it('应该正确修改客户状态', async () => {
    const wrapper = mount(CustomerStatusTracker)
    await wrapper.vm.handleStatusSubmit()
    expect(wrapper.vm.statusDialogVisible).toBe(false)
  })
})
```

### 8.2 集成测试

#### 8.2.1 测试场景

1. 客户创建到分群的完整流程
2. 客户生命周期自动流转
3. RFM评分计算和客户等级划分
4. 流失预测和预警处理

### 8.3 E2E测试

#### 8.3.1 测试框架

- **Playwright**

#### 8.3.2 测试示例

```typescript
test('客户状态跟踪完整流程', async ({ page }) => {
  await page.goto('/customer/status-tracker')
  await page.fill('input[name="keyword"]', '张三')
  await page.click('button:has-text("搜索")')
  await expect(page.locator('table')).toBeVisible()
})
```

---

## 9. 部署指南

### 9.1 前端部署

#### 9.1.1 构建命令

```bash
npm run build
```

#### 9.1.2 部署到Nginx

```nginx
server {
  listen 80;
  server_name admin.yyc3.com;

  root /var/www/admin-dashboard/dist;
  index index.html;

  location / {
    try_files $uri $uri/ /index.html;
  }

  location /api {
    proxy_pass http://localhost:3006;
  }
}
```

### 9.2 后端部署

#### 9.2.1 环境变量

```env
NODE_ENV=production
PORT=3006
DATABASE_URL=postgresql://user:password@localhost:5432/yyc3
JWT_SECRET=your-secret-key
```

#### 9.2.2 使用PM2部署

```bash
npm install -g pm2
pm2 start npm --name "yyc3-api" -- start
pm2 save
pm2 startup
```

### 9.3 数据库部署

#### 9.3.1 创建数据库

```sql
CREATE DATABASE yyc3;
```

#### 9.3.2 执行迁移

```bash
npm run migrate
```

---

## 10. 常见问题

### 10.1 开发问题

**Q：如何添加新的客户分群类型？**

A：在`customer.ts`中的`CustomerGroup`接口中添加新的`groupType`值，并在数据库中添加相应的CHECK约束。

**Q：如何修改RFM评分标准？**

A：在`useRFMModel.ts`中修改`calculateRecencyScore`、`calculateFrequencyScore`、`calculateMonetaryScore`方法的评分逻辑。

### 10.2 性能问题

**Q：客户列表加载缓慢怎么办？**

A：检查数据库索引是否正确创建，考虑添加分页和缓存机制。

**Q：RFM计算耗时过长怎么办？**

A：考虑使用后台任务异步计算，或使用缓存存储计算结果。

### 10.3 部署问题

**Q：部署后API接口404怎么办？**

A：检查Nginx配置中的`proxy_pass`是否正确，确保后端服务正在运行。

**Q：数据库连接失败怎么办？**

A：检查数据库连接字符串是否正确，确保数据库服务正在运行，检查防火墙设置。

---

## 附录

### A. 相关文档

- [用户操作手册](./YYC3-Cater-用户操作手册.md)
- [API接口文档](./YYC3-Cater-接口文档/客户生命周期管理API接口文档.md)
- [数据模型设计文档](../../YYC3-CP-详细设计/041-YYC3-AICP-详细设计-数据模型设计文档.md)

### B. 版本历史

| 版本 | 日期 | 更新内容 |
|------|------|----------|
| v1.0.0 | 2026-01-20 | 初始版本 |

---

> 「***YanYuCloudCube***」
> 「***<admin@0379.email>***」
> 「***Words Initiate Quadrants, Language Serves as Core for the Future***」
> 「***All things converge in the cloud pivot; Deep stacks ignite a new era of intelligence***」
