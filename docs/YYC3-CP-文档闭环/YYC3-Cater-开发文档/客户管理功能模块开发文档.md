# 客户管理功能模块开发文档

## 模块概述

客户管理模块是YYC³餐饮行业智能化平台的核心功能模块，提供客户信息的创建、查询、更新、删除(CRUD)基础功能，以及客户分类管理、客户状态跟踪、客户历史记录查询等扩展功能。该模块采用Vue 3 + TypeScript + Element Plus技术栈，使用Pinia进行状态管理。

## 技术架构

### 1. 技术栈
- **前端框架**: Vue 3.4+ (Composition API)
- **UI组件库**: Element Plus 2.4+
- **状态管理**: Pinia 2.1+
- **路由管理**: Vue Router 4.2+
- **HTTP客户端**: Fetch API
- **类型检查**: TypeScript 5.3+
- **构建工具**: Vite 5.4+

### 2. 目录结构
```
src/
├── views/
│   └── CustomerManagement.vue          # 客户管理主页面
├── components/
│   └── Customer/
│       ├── CustomerDetail.vue          # 客户详情组件
│       ├── CustomerForm.vue            # 客户表单组件
│       ├── CustomerLoyalty.vue        # 客户会员管理组件
│       ├── CustomerSegment.vue         # 客户分群组件
│       ├── CustomerOrderHistory.vue    # 客户订单历史组件
│       ├── CustomerTrendChart.vue     # 客户趋势图表组件
│       ├── CustomerStatusTracker.vue   # 客户状态跟踪组件
│       ├── CustomerHistoryQuery.vue    # 客户历史记录查询组件
│       ├── CustomerSegmentManager.vue   # 客户分群管理组件
│       └── __tests__/
│           ├── CustomerDetail.test.ts
│           ├── CustomerForm.test.ts
│           ├── CustomerLoyalty.test.ts
│           ├── CustomerSegment.test.ts
│           ├── CustomerOrderHistory.test.ts
│           ├── CustomerTrendChart.test.ts
│           ├── CustomerStatusTracker.test.ts
│           ├── CustomerHistoryQuery.test.ts
│           └── CustomerSegmentManager.test.ts
├── api/
│   └── customer.ts                   # 客户管理API接口
├── stores/
│   └── customer.ts                   # 客户状态管理
└── types/
    └── customer.ts                   # 客户类型定义
```

## 数据库设计

### 1. 客户信息表 (customer_profiles)

```sql
CREATE TABLE customer_profiles (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id VARCHAR(36) NOT NULL UNIQUE,
    phone VARCHAR(20),
    birth_date DATE,
    gender VARCHAR(10),
    avatar_url VARCHAR(500),
    preferences JSONB, -- 饮食偏好：['素食', '无辣', '清真']
    allergies JSONB, -- 过敏信息：['花生', '海鲜']
    favorite_dishes JSONB, -- 最喜欢的菜品ID数组
    dietary_restrictions JSONB, -- 饮食限制
    loyalty_points INTEGER DEFAULT 0,
    membership_level VARCHAR(20) DEFAULT 'bronze', -- bronze, silver, gold, platinum
    total_orders INTEGER DEFAULT 0,
    total_spent DECIMAL(12,2) DEFAULT 0.00,
    last_visit_at TIMESTAMPTZ,
    is_vip BOOLEAN DEFAULT FALSE,
    tenant_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**字段说明**：
- `id`: 客户唯一标识
- `user_id`: 关联的用户ID
- `phone`: 客户手机号
- `birth_date`: 客户生日
- `gender`: 客户性别
- `avatar_url`: 客户头像URL
- `preferences`: 客户饮食偏好（JSONB）
- `allergies`: 客户过敏信息（JSONB）
- `favorite_dishes`: 客户喜欢的菜品（JSONB）
- `dietary_restrictions`: 客户饮食限制（JSONB）
- `loyalty_points`: 客户积分
- `membership_level`: 客户会员等级
- `total_orders`: 客户总订单数
- `total_spent`: 客户总消费金额
- `last_visit_at`: 客户最后访问时间
- `is_vip`: 是否VIP客户
- `tenant_id`: 租户ID
- `created_at`: 创建时间
- `updated_at`: 更新时间

**索引**：
```sql
CREATE INDEX idx_customer_profiles_user_id ON customer_profiles(user_id);
CREATE INDEX idx_customer_profiles_tenant_id ON customer_profiles(tenant_id);
CREATE INDEX idx_customer_profiles_phone ON customer_profiles(phone);
CREATE INDEX idx_customer_profiles_membership_level ON customer_profiles(membership_level);
CREATE INDEX idx_customer_profiles_last_visit_at ON customer_profiles(last_visit_at);
```

### 2. 客户状态记录表 (customer_status_history)

```sql
CREATE TABLE customer_status_history (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    customer_id UUID NOT NULL REFERENCES customer_profiles(id) ON DELETE CASCADE,
    status VARCHAR(20) NOT NULL, -- active, inactive, churned, blacklisted
    operator VARCHAR(255),
    note TEXT,
    duration INTEGER, -- 持续时间（秒）
    tenant_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW()
);
```

**字段说明**：
- `id`: 状态记录唯一标识
- `customer_id`: 客户ID
- `status`: 客户状态
- `operator`: 操作人
- `note`: 备注信息
- `duration`: 状态持续时间
- `tenant_id`: 租户ID
- `created_at`: 创建时间

**索引**：
```sql
CREATE INDEX idx_customer_status_history_customer_id ON customer_status_history(customer_id);
CREATE INDEX idx_customer_status_history_status ON customer_status_history(status);
CREATE INDEX idx_customer_status_history_created_at ON customer_status_history(created_at);
```

### 3. 客户分群表 (customer_segments)

```sql
CREATE TABLE customer_segments (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    name VARCHAR(255) NOT NULL,
    type VARCHAR(20) NOT NULL, -- manual, automatic, ai
    description TEXT,
    customer_count INTEGER DEFAULT 0,
    percentage DECIMAL(5,2) DEFAULT 0.00,
    avg_spent DECIMAL(12,2) DEFAULT 0.00,
    avg_orders DECIMAL(10,2) DEFAULT 0.00,
    rules JSONB, -- 分群规则（JSONB）
    logic VARCHAR(5) DEFAULT 'and', -- and, or
    tenant_id VARCHAR(36) NOT NULL,
    created_at TIMESTAMPTZ DEFAULT NOW(),
    updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**字段说明**：
- `id`: 分群唯一标识
- `name`: 分群名称
- `type`: 分群类型
- `description`: 分群描述
- `customer_count`: 分群客户数量
- `percentage`: 分群占比
- `avg_spent`: 平均消费金额
- `avg_orders`: 平均订单数量
- `rules`: 分群规则（JSONB）
- `logic`: 规则逻辑关系
- `tenant_id`: 租户ID
- `created_at`: 创建时间
- `updated_at`: 更新时间

**索引**：
```sql
CREATE INDEX idx_customer_segments_tenant_id ON customer_segments(tenant_id);
CREATE INDEX idx_customer_segments_type ON customer_segments(type);
```

## 核心组件

### 1. CustomerManagement组件

#### 1.1 组件说明
客户管理主页面组件，提供客户列表展示、筛选、搜索、分页等功能。

#### 1.2 核心功能
- 客户列表展示
- 客户信息搜索
- 客户筛选（等级、分群、状态）
- 客户详情查看
- 客户编辑和删除
- 客户数据导出
- 客户分群管理

#### 1.3 组件Props
```typescript
interface CustomerManagementProps {
  // 无Props
}
```

#### 1.4 组件Events
```typescript
interface CustomerManagementEmits {
  (e: 'customer-selected', customer: Customer): void
  (e: 'customer-updated', customer: Customer): void
  (e: 'customer-deleted', customerId: string): void
}
```

### 2. CustomerDetail组件

#### 2.1 组件说明
客户详情组件，展示客户的完整信息，包括基本信息、消费统计、订单历史等。

#### 2.2 核心功能
- 客户基本信息展示
- 客户消费统计
- 客户订单历史
- 客户积分记录
- 客户优惠券记录
- 客户评价记录
- 客户投诉记录

#### 2.3 组件Props
```typescript
interface CustomerDetailProps {
  customer: Customer
}
```

#### 2.4 组件Events
```typescript
interface CustomerDetailEmits {
  (e: 'updated', customer: Customer): void
}
```

### 3. CustomerStatusTracker组件

#### 3.1 组件说明
客户状态跟踪组件，提供客户状态的实时监控和历史记录功能。

#### 3.2 核心功能
- 当前状态展示
- 状态变化历史
- 状态指标统计
- 状态预测
- 添加状态记录

#### 3.3 组件Props
```typescript
interface CustomerStatusTrackerProps {
  customerId: string
}
```

#### 3.4 组件Events
```typescript
interface CustomerStatusTrackerEmits {
  (e: 'status-updated', status: string): void
}
```

### 4. CustomerHistoryQuery组件

#### 4.1 组件说明
客户历史记录查询组件，提供客户各类历史记录的查询功能。

#### 4.2 核心功能
- 订单记录查询
- 积分记录查询
- 优惠券记录查询
- 评价记录查询
- 投诉记录查询
- 历史记录导出

#### 4.3 组件Props
```typescript
interface CustomerHistoryQueryProps {
  customerId: string
}
```

#### 4.4 组件Events
```typescript
interface CustomerHistoryQueryEmits {
  (e: 'history-exported', data: any): void
}
```

### 5. CustomerSegmentManager组件

#### 5.1 组件说明
客户分群管理组件，提供客户分群的创建、编辑、删除功能。

#### 5.2 核心功能
- 分群列表展示
- 分群详情查看
- 新建分群
- 编辑分群
- 删除分群
- 分群规则设置
- 分群数据导出

#### 5.3 组件Props
```typescript
interface CustomerSegmentManagerProps {
  // 无Props
}
```

#### 5.4 组件Events
```typescript
interface CustomerSegmentManagerEmits {
  (e: 'segment-created', segment: CustomerSegment): void
  (e: 'segment-updated', segment: CustomerSegment): void
  (e: 'segment-deleted', segmentId: string): void
}
```

## API接口

### 1. 客户管理接口

#### 1.1 获取客户列表
```typescript
interface GetCustomersParams {
  keyword?: string
  status?: 'active' | 'inactive'
  memberLevelId?: string
  segment?: string
  page?: number
  size?: number
  sortBy?: string
  sortOrder?: 'asc' | 'desc'
}

interface GetCustomersResponse {
  success: boolean
  data: {
    items: Customer[]
    pagination: {
      page: number
      size: number
      total: number
      totalPages: number
    }
  }
}

export function getCustomers(params: GetCustomersParams): Promise<GetCustomersResponse>
```

#### 1.2 获取客户详情
```typescript
export function getCustomerDetail(customerId: string): Promise<{
  success: boolean
  data: Customer
}>
```

#### 1.3 创建客户
```typescript
interface CreateCustomerRequest {
  name: string
  phone: string
  email?: string
  gender?: 'male' | 'female' | 'other'
  birthday?: string
  address?: string
  memberLevelId?: string
}

export function createCustomer(data: CreateCustomerRequest): Promise<{
  success: boolean
  data: Customer
}>
```

#### 1.4 更新客户
```typescript
export function updateCustomer(customerId: string, data: Partial<CreateCustomerRequest>): Promise<{
  success: boolean
  data: Customer
}>
```

#### 1.5 删除客户
```typescript
export function deleteCustomer(customerId: string): Promise<{
  success: boolean
  message: string
}>
```

#### 1.6 批量删除客户
```typescript
interface BatchDeleteRequest {
  ids: string[]
}

export function batchDeleteCustomers(data: BatchDeleteRequest): Promise<{
  success: boolean
  message: string
}>
```

#### 1.7 更新客户状态
```typescript
interface UpdateStatusRequest {
  status: 'active' | 'inactive'
}

export function updateCustomerStatus(customerId: string, data: UpdateStatusRequest): Promise<{
  success: boolean
  message: string
}>
```

### 2. 客户状态接口

#### 2.1 获取客户状态历史
```typescript
export function getCustomerStatusHistory(customerId: string): Promise<{
  success: boolean
  data: {
    history: StatusEvent[]
    prediction: StatusPrediction
  }
}>
```

#### 2.2 添加客户状态记录
```typescript
interface AddStatusRequest {
  status: string
  note: string
  operator: string
}

export function addCustomerStatus(customerId: string, data: AddStatusRequest): Promise<{
  success: boolean
  message: string
}>
```

### 3. 客户历史记录接口

#### 3.1 获取客户历史记录
```typescript
interface GetHistoryParams {
  type?: string
  startTime?: string
  endTime?: string
}

export function getCustomerHistory(customerId: string, params: GetHistoryParams): Promise<{
  success: boolean
  data: {
    orders: OrderHistory[]
    points: PointsHistory[]
    coupons: CouponHistory[]
    reviews: ReviewHistory[]
    complaints: ComplaintHistory[]
  }
}>
```

#### 3.2 导出客户历史记录
```typescript
export function exportCustomerHistory(customerId: string, params: GetHistoryParams): Promise<Blob>
```

### 4. 客户分群接口

#### 4.1 获取客户分群列表
```typescript
export function getCustomerSegments(): Promise<{
  success: boolean
  data: CustomerSegment[]
}>
```

#### 4.2 创建客户分群
```typescript
interface CreateSegmentRequest {
  name: string
  type: 'manual' | 'automatic' | 'ai'
  description: string
  rules: SegmentRule[]
  logic: 'and' | 'or'
}

export function createCustomerSegment(data: CreateSegmentRequest): Promise<{
  success: boolean
  data: CustomerSegment
}>
```

#### 4.3 更新客户分群
```typescript
export function updateCustomerSegment(segmentId: string, data: Partial<CreateSegmentRequest>): Promise<{
  success: boolean
  data: CustomerSegment
}>
```

#### 4.4 删除客户分群
```typescript
export function deleteCustomerSegment(segmentId: string): Promise<{
  success: boolean
  message: string
}>
```

#### 4.5 导出分群客户
```typescript
export function exportSegmentCustomers(segmentId: string): Promise<Blob>
```

## 类型定义

### 1. 客户类型
```typescript
export interface Customer {
  id: string
  name: string
  phone: string
  email?: string
  gender?: 'male' | 'female' | 'other'
  birthday?: string
  address?: string
  avatar?: string
  memberLevelId?: string
  points?: number
  totalOrders?: number
  totalSpent?: number
  averageOrderValue?: number
  lastVisit?: string
  level?: 'regular' | 'member' | 'vip' | 'new'
  status: 'active' | 'inactive' | 'blacklisted'
  preferences?: string[]
  allergies?: string[]
  notes?: string
  createdAt: string
  updatedAt: string
}
```

### 2. 客户状态类型
```typescript
export interface StatusEvent {
  id: number
  status: string
  timestamp: string
  operator?: string
  note?: string
  duration?: number
}

export interface StatusPrediction {
  label: string
  type: string
  description: string
}
```

### 3. 客户历史记录类型
```typescript
export interface OrderHistory {
  orderNumber: string
  orderTime: string
  amount: number
  items: any[]
  status: string
  paymentMethod: string
}

export interface PointsHistory {
  transactionId: string
  transactionTime: string
  type: string
  points: number
  balance: number
  description: string
  operator: string
}

export interface CouponHistory {
  couponCode: string
  couponName: string
  receivedTime: string
  usedTime?: string
  discount: number
  status: string
  expireTime: string
}

export interface ReviewHistory {
  reviewId: string
  reviewTime: string
  orderNumber: string
  rating: number
  content: string
  reply?: string
  status: string
}

export interface ComplaintHistory {
  complaintId: string
  complaintTime: string
  type: string
  content: string
  status: string
  handler?: string
  handleTime?: string
  reply?: string
}
```

### 4. 客户分群类型
```typescript
export interface CustomerSegment {
  id: string
  name: string
  type: 'manual' | 'automatic' | 'ai'
  description: string
  customerCount: number
  percentage: number
  avgSpent: number
  avgOrders: number
  rules: SegmentRule[]
  logic: 'and' | 'or'
  createdAt: string
  updatedAt: string
}

export interface SegmentRule {
  type: string
  operator: string
  value: string
}
```

## 状态管理

### 1. Customer Store

```typescript
export const useCustomerStore = defineStore('customer', () => {
  const loading = ref(false)
  const error = ref<string | null>(null)
  const customers = ref<Customer[]>([])
  const selectedCustomer = ref<Customer | null>(null)
  const segments = ref<CustomerSegment[]>([])

  async function fetchCustomers(params: GetCustomersParams) {
    loading.value = true
    try {
      const response = await getCustomers(params)
      if (response.success) {
        customers.value = response.data.items
      }
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
    } finally {
      loading.value = false
    }
  }

  async function fetchCustomerDetail(customerId: string) {
    loading.value = true
    try {
      const response = await getCustomerDetail(customerId)
      if (response.success) {
        selectedCustomer.value = response.data
      }
      return response
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
      throw err
    } finally {
      loading.value = false
    }
  }

  async function createCustomer(data: CreateCustomerRequest) {
    loading.value = true
    try {
      const response = await createCustomer(data)
      if (response.success) {
        customers.value.unshift(response.data)
      }
      return response
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
      throw err
    } finally {
      loading.value = false
    }
  }

  async function updateCustomer(customerId: string, data: Partial<CreateCustomerRequest>) {
    loading.value = true
    try {
      const response = await updateCustomer(customerId, data)
      if (response.success) {
        const index = customers.value.findIndex(c => c.id === customerId)
        if (index !== -1) {
          customers.value[index] = response.data
        }
      }
      return response
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
      throw err
    } finally {
      loading.value = false
    }
  }

  async function deleteCustomer(customerId: string) {
    loading.value = true
    try {
      const response = await deleteCustomer(customerId)
      if (response.success) {
        customers.value = customers.value.filter(c => c.id !== customerId)
      }
      return response
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Unknown error'
      throw err
    } finally {
      loading.value = false
    }
  }

  return {
    loading,
    error,
    customers,
    selectedCustomer,
    segments,
    fetchCustomers,
    fetchCustomerDetail,
    createCustomer,
    updateCustomer,
    deleteCustomer
  }
})
```

## 测试

### 1. 单元测试

#### 1.1 CustomerDetail组件测试
```typescript
describe('CustomerDetail组件', () => {
  it('应该正确渲染客户信息', () => {
    const mockCustomer = {
      id: '1',
      name: '张三',
      phone: '13800138000',
      email: 'zhangsan@example.com',
      status: 'active',
      level: 'vip',
      createdAt: '2025-01-01T00:00:00Z'
    }
    const wrapper = mount(CustomerDetail, {
      props: {
        customer: mockCustomer
      }
    })
    expect(wrapper.find('.customer-name').text()).toBe('张三')
    expect(wrapper.find('.customer-phone').text()).toBe('13800138000')
  })

  it('应该能够编辑客户', async () => {
    const wrapper = mount(CustomerDetail, {
      props: {
        customer: mockCustomer
      }
    })
    await wrapper.vm.handleEdit()
    expect(wrapper.emitted('edit')).toBeTruthy()
  })
})
```

#### 1.2 CustomerStatusTracker组件测试
```typescript
describe('CustomerStatusTracker组件', () => {
  it('应该正确渲染状态历史', () => {
    const wrapper = mount(CustomerStatusTracker, {
      props: {
        customerId: '1'
      }
    })
    expect(wrapper.find('.status-timeline').exists()).toBe(true)
  })

  it('应该能够添加状态记录', async () => {
    const wrapper = mount(CustomerStatusTracker, {
      props: {
        customerId: '1'
      }
    })
    wrapper.vm.formData.status = 'active'
    wrapper.vm.formData.note = '测试备注'
    wrapper.vm.formData.operator = '测试人员'
    await wrapper.vm.handleSubmit()
    expect(wrapper.vm.showAddStatusDialog).toBe(false)
  })
})
```

#### 1.3 CustomerHistoryQuery组件测试
```typescript
describe('CustomerHistoryQuery组件', () => {
  it('应该正确渲染历史记录标签页', () => {
    const wrapper = mount(CustomerHistoryQuery, {
      props: {
        customerId: '1'
      }
    })
    expect(wrapper.find('.history-tabs').exists()).toBe(true)
  })

  it('应该能够切换标签页', async () => {
    const wrapper = mount(CustomerHistoryQuery, {
      props: {
        customerId: '1'
      }
    })
    await wrapper.vm.activeTab = 'points'
    expect(wrapper.vm.activeTab).toBe('points')
  })
})
```

#### 1.4 CustomerSegmentManager组件测试
```typescript
describe('CustomerSegmentManager组件', () => {
  it('应该正确渲染分群列表', () => {
    const wrapper = mount(CustomerSegmentManager)
    expect(wrapper.find('.segment-list').exists()).toBe(true)
  })

  it('应该能够选择分群', async () => {
    const wrapper = mount(CustomerSegmentManager)
    const mockSegment = {
      id: '1',
      name: '高价值客户',
      type: 'automatic',
      customerCount: 156,
      percentage: 15.6,
      avgSpent: 580.50,
      avgOrders: 12.3,
      rules: [],
      logic: 'and',
      createdAt: '2025-01-01T00:00:00Z',
      updatedAt: '2025-01-15T00:00:00Z'
    }
    await wrapper.vm.selectSegment(mockSegment)
    expect(wrapper.vm.selectedSegment).toEqual(mockSegment)
  })
})
```

## 性能优化

### 1. 组件优化
- 使用Vue 3 Composition API减少不必要的重渲染
- 使用computed缓存计算结果
- 使用v-memo优化列表渲染
- 使用虚拟滚动优化大数据量列表

### 2. 数据优化
- 使用请求缓存减少重复请求
- 使用分页加载减少数据传输量
- 使用数据预加载提升用户体验
- 使用WebSocket实现实时数据更新

### 3. 查询优化
- 使用数据库索引提升查询性能
- 使用查询缓存减少数据库压力
- 使用批量查询减少网络请求
- 使用延迟加载提升初始加载速度

## 部署说明

### 1. 环境要求
- Node.js >= 18.0.0
- npm >= 9.0.0

### 2. 安装依赖
```bash
npm install
```

### 3. 开发环境
```bash
npm run dev
```

### 4. 生产构建
```bash
npm run build
```

### 5. 运行测试
```bash
npm run test
```

### 6. 代码检查
```bash
npm run lint
npm run type-check
```

## 开发规范

### 1. 代码风格
- 使用TypeScript进行类型检查
- 遵循ESLint代码规范
- 使用Prettier进行代码格式化
- 遵循Vue 3 Composition API最佳实践

### 2. 命名规范
- 组件名使用PascalCase
- 文件名使用PascalCase
- 变量名使用camelCase
- 常量名使用UPPER_SNAKE_CASE

### 3. 注释规范
- 使用JSDoc注释函数和类
- 使用单行注释解释复杂逻辑
- 使用TODO标记待完成功能

### 4. Git提交规范
```
feat: 新功能
fix: 修复bug
docs: 文档更新
style: 代码格式调整
refactor: 代码重构
test: 测试相关
chore: 构建/工具相关
```

## 版本历史

### v1.0.0 (2025-01-20)
- 初始版本发布
- 实现客户信息管理功能
- 实现客户状态跟踪功能
- 实现客户历史记录查询功能
- 实现客户分群管理功能
- 实现客户会员管理功能
- 完成单元测试覆盖
- 完成用户手册和开发文档

## 联系方式

如有任何问题或建议，请联系开发团队：
- 邮箱: dev@yyc3.com
- 项目地址: https://github.com/yyc3/catering-platform

## 生命周期管理功能

### 1. 功能概述

生命周期管理功能提供客户生命周期的全面跟踪和管理，帮助管理者了解客户从新客户到忠诚客户的完整生命周期过程，实现精准的客户管理。

### 2. 组件设计

#### 2.1 CustomerLifecycleManager组件

**组件说明**：客户生命周期管理主组件，提供生命周期阶段管理、客户列表展示、阶段调整等功能。

**核心功能**：
- 生命周期阶段分布展示
- 各阶段客户列表查看
- 客户生命周期阶段调整
- 批量阶段调整
- 生命周期数据导出

**组件Props**：
```typescript
interface CustomerLifecycleManagerProps {
  // 无Props
}
```

**组件Events**：
```typescript
interface CustomerLifecycleManagerEmits {
  (e: 'stage-updated', data: { customerId: string; stage: string }): void
  (e: 'batch-updated', data: { customerIds: string[]; stage: string }): void
}
```

**实现要点**：
- 使用el-tabs组件组织不同生命周期阶段
- 使用el-table组件展示客户列表
- 使用el-dialog组件实现阶段调整对话框
- 使用el-select组件选择目标阶段
- 实现批量选择和批量操作功能

### 3. RFM客户价值评估功能

### 3.1 功能概述

RFM客户价值评估功能基于RFM模型（最近消费、消费频次、消费金额）对客户进行价值评估和分群，帮助管理者识别高价值客户，制定差异化营销策略。

### 3.2 组件设计

#### 3.2.1 CustomerValueAssessment组件

**组件说明**：RFM客户价值评估组件，提供RFM指标计算、客户分群、价值排名等功能。

**核心功能**：
- RFM指标概览展示
- 客户价值分群展示
- RFM评分详情查看
- 客户价值排名
- RFM参数配置
- RFM数据导出

**组件Props**：
```typescript
interface CustomerValueAssessmentProps {
  // 无Props
}
```

**组件Events**：
```typescript
interface CustomerValueAssessmentEmits {
  (e: 'config-updated', config: RFMConfig): void
  (e: 'segment-viewed', segment: string): void
}
```

**实现要点**：
- 使用el-card组件组织RFM概览和分群信息
- 使用el-row和el-col组件实现响应式布局
- 使用el-progress组件展示流失概率
- 使用el-table组件展示客户列表
- 使用el-dialog组件实现参数配置对话框
- 实现RFM评分计算逻辑

**RFM评分算法**：
```typescript
function calculateRFMScore(customer: Customer, config: RFMConfig): RFMScore {
  const recencyScore = calculateRecencyScore(customer.lastVisit, config.recencyRules)
  const frequencyScore = calculateFrequencyScore(customer.totalOrders, config.frequencyRules)
  const monetaryScore = calculateMonetaryScore(customer.totalSpent, config.monetaryRules)
  
  return {
    recency: recencyScore,
    frequency: frequencyScore,
    monetary: monetaryScore,
    total: recencyScore + frequencyScore + monetaryScore
  }
}

function calculateRecencyScore(lastVisit: string, rules: RecencyRule[]): number {
  const daysSinceLastVisit = Math.floor((Date.now() - new Date(lastVisit).getTime()) / (1000 * 60 * 60 * 24))
  for (const rule of rules) {
    if (daysSinceLastVisit <= rule.maxDays) {
      return rule.score
    }
  }
  return 1
}

function calculateFrequencyScore(totalOrders: number, rules: FrequencyRule[]): number {
  for (const rule of rules) {
    if (totalOrders >= rule.minOrders) {
      return rule.score
    }
  }
  return 1
}

function calculateMonetaryScore(totalSpent: number, rules: MonetaryRule[]): number {
  for (const rule of rules) {
    if (totalSpent >= rule.minAmount) {
      return rule.score
    }
  }
  return 1
}
```

**客户分群逻辑**：
```typescript
function segmentCustomer(rfmScore: RFMScore): CustomerSegment {
  const { recency, frequency, monetary } = rfmScore
  
  if (recency >= 4 && frequency >= 4 && monetary >= 4) {
    return { code: 'R高F高M高', name: '重要价值客户', tagType: 'success' }
  } else if (recency >= 4 && frequency < 4 && monetary >= 4) {
    return { code: 'R高F低M高', name: '重要发展客户', tagType: 'warning' }
  } else if (recency < 4 && frequency >= 4 && monetary >= 4) {
    return { code: 'R低F高M高', name: '重要保持客户', tagType: 'danger' }
  } else if (recency < 4 && frequency < 4 && monetary >= 4) {
    return { code: 'R低F低M高', name: '重要挽留客户', tagType: 'danger' }
  } else if (recency >= 4 && frequency >= 4 && monetary < 4) {
    return { code: 'R高F高M低', name: '一般价值客户', tagType: 'info' }
  } else if (recency >= 4 && frequency < 4 && monetary < 4) {
    return { code: 'R高F低M低', name: '一般发展客户', tagType: 'info' }
  } else if (recency < 4 && frequency >= 4 && monetary < 4) {
    return { code: 'R低F高M低', name: '一般保持客户', tagType: 'warning' }
  } else {
    return { code: 'R低F低M低', name: '一般挽留客户', tagType: 'info' }
  }
}
```

### 4. 客户流失预测功能

### 4.1 功能概述

客户流失预测功能利用机器学习模型预测客户的流失风险，帮助管理者提前识别流失风险客户，采取干预措施，降低客户流失率。

### 4.2 组件设计

#### 4.2.1 CustomerChurnPrediction组件

**组件说明**：客户流失预测组件，提供流失风险评估、风险因素分析、干预措施管理等功能。

**核心功能**：
- 流失风险概览展示
- 流失风险因素分析
- 高风险客户列表
- 客户干预措施
- 预测模型配置
- 预测数据导出

**组件Props**：
```typescript
interface CustomerChurnPredictionProps {
  // 无Props
}
```

**组件Events**：
```typescript
interface CustomerChurnPredictionEmits {
  (e: 'intervention-executed', data: { customerId: string; intervention: string }): void
  (e: 'model-updated', config: ModelConfig): void
}
```

**实现要点**：
- 使用el-card组件组织流失概览和客户列表
- 使用el-progress组件展示流失概率
- 使用el-tag组件标识风险等级
- 使用el-table组件展示高风险客户列表
- 使用el-dialog组件实现干预和配置对话框
- 实现流失风险计算逻辑

**流失风险计算算法**：
```typescript
function calculateChurnRisk(customer: Customer): ChurnRisk {
  const factors: RiskFactor[] = []
  
  // 消费频次下降
  if (customer.recentOrderCount < customer.averageOrderCount * 0.5) {
    factors.push({
      type: 'frequency_decline',
      weight: 0.3,
      description: '消费频次明显下降'
    })
  }
  
  // 消费金额下降
  if (customer.recentSpent < customer.averageSpent * 0.5) {
    factors.push({
      type: 'monetary_decline',
      weight: 0.25,
      description: '消费金额明显下降'
    })
  }
  
  // 投诉增加
  if (customer.recentComplaints > 2) {
    factors.push({
      type: 'complaint_increase',
      weight: 0.2,
      description: '近期投诉次数增加'
    })
  }
  
  // 评价下降
  if (customer.recentRating < customer.averageRating - 1) {
    factors.push({
      type: 'rating_decline',
      weight: 0.15,
      description: '近期评价分数下降'
    })
  }
  
  // 长时间未访问
  const daysSinceLastVisit = Math.floor((Date.now() - new Date(customer.lastVisit).getTime()) / (1000 * 60 * 60 * 24))
  if (daysSinceLastVisit > 60) {
    factors.push({
      type: 'inactive',
      weight: 0.1,
      description: '长时间未访问'
    })
  }
  
  const totalWeight = factors.reduce((sum, factor) => sum + factor.weight, 0)
  const churnProbability = Math.min(totalWeight * 100, 100)
  
  return {
    probability: churnProbability,
    level: churnProbability > 70 ? 'high' : churnProbability > 40 ? 'medium' : 'low',
    factors
  }
}
```

### 5. 智能客户关怀提醒功能

### 5.1 功能概述

智能客户关怀提醒功能帮助管理者及时对客户进行关怀，提升客户满意度和忠诚度，降低客户流失率。

### 5.2 组件设计

#### 5.2.1 CustomerCareReminder组件

**组件说明**：智能客户关怀提醒组件，提供关怀任务管理、自动关怀规则配置、关怀效果跟踪等功能。

**核心功能**：
- 关怀任务列表展示
- 关怀任务处理
- 新建关怀任务
- 自动关怀规则配置
- 关怀效果跟踪
- 关怀数据导出

**组件Props**：
```typescript
interface CustomerCareReminderProps {
  // 无Props
}
```

**组件Events**：
```typescript
interface CustomerCareReminderEmits {
  (e: 'care-completed', data: { careId: string; result: string }): void
  (e: 'rule-updated', rule: CareRule): void
}
```

**实现要点**：
- 使用el-card组件组织关怀概览和任务列表
- 使用el-table组件展示关怀任务
- 使用el-tag组件标识关怀类型和状态
- 使用el-dialog组件实现新建关怀和配置规则对话框
- 使用el-form组件实现表单输入
- 实现关怀任务管理逻辑

**自动关怀规则引擎**：
```typescript
class CareRuleEngine {
  private rules: CareRule[]
  
  constructor(rules: CareRule[]) {
    this.rules = rules.filter(rule => rule.enabled)
  }
  
  evaluate(customer: Customer): CareAction[] {
    const actions: CareAction[] = []
    
    for (const rule of this.rules) {
      if (this.matchRule(customer, rule)) {
        actions.push(...rule.actions)
      }
    }
    
    return actions
  }
  
  private matchRule(customer: Customer, rule: CareRule): boolean {
    for (const condition of rule.conditions) {
      if (!this.matchCondition(customer, condition)) {
        return false
      }
    }
    return true
  }
  
  private matchCondition(customer: Customer, condition: CareCondition): boolean {
    switch (condition.type) {
      case 'birthday':
        return this.matchBirthdayCondition(customer, condition)
      case 'holiday':
        return this.matchHolidayCondition(condition)
      case 'after_order':
        return this.matchAfterOrderCondition(customer, condition)
      case 'inactive':
        return this.matchInactiveCondition(customer, condition)
      case 'churn_risk':
        return this.matchChurnRiskCondition(customer, condition)
      default:
        return false
    }
  }
  
  private matchBirthdayCondition(customer: Customer, condition: CareCondition): boolean {
    if (!customer.birthday) return false
    const birthday = new Date(customer.birthday)
    const today = new Date()
    const daysUntilBirthday = this.daysUntilDate(birthday, today)
    return daysUntilBirthday <= condition.days
  }
  
  private matchHolidayCondition(condition: CareCondition): boolean {
    const holidays = this.getUpcomingHolidays()
    const nextHoliday = holidays[0]
    if (!nextHoliday) return false
    const daysUntilHoliday = this.daysUntilDate(nextHoliday.date, new Date())
    return daysUntilHoliday <= condition.days
  }
  
  private matchAfterOrderCondition(customer: Customer, condition: CareCondition): boolean {
    if (!customer.lastOrderTime) return false
    const hoursSinceLastOrder = (Date.now() - new Date(customer.lastOrderTime).getTime()) / (1000 * 60 * 60)
    return hoursSinceLastOrder <= condition.hours
  }
  
  private matchInactiveCondition(customer: Customer, condition: CareCondition): boolean {
    if (!customer.lastVisit) return false
    const daysSinceLastVisit = Math.floor((Date.now() - new Date(customer.lastVisit).getTime()) / (1000 * 60 * 60 * 24))
    return daysSinceLastVisit >= condition.days
  }
  
  private matchChurnRiskCondition(customer: Customer, condition: CareCondition): boolean {
    const churnRisk = calculateChurnRisk(customer)
    return churnRisk.probability >= condition.threshold
  }
  
  private daysUntilDate(date: Date, from: Date): number {
    const targetDate = new Date(from.getFullYear(), date.getMonth(), date.getDate())
    if (targetDate < from) {
      targetDate.setFullYear(targetDate.getFullYear() + 1)
    }
    return Math.floor((targetDate.getTime() - from.getTime()) / (1000 * 60 * 60 * 24))
  }
  
  private getUpcomingHolidays(): Holiday[] {
    const today = new Date()
    const currentYear = today.getFullYear()
    const holidays: Holiday[] = [
      { name: '春节', date: new Date(currentYear, 0, 1) },
      { name: '情人节', date: new Date(currentYear, 1, 14) },
      { name: '妇女节', date: new Date(currentYear, 2, 8) },
      { name: '劳动节', date: new Date(currentYear, 4, 1) },
      { name: '母亲节', date: new Date(currentYear, 4, 12) },
      { name: '端午节', date: new Date(currentYear, 5, 20) },
      { name: '父亲节', date: new Date(currentYear, 5, 16) },
      { name: '七夕节', date: new Date(currentYear, 7, 7) },
      { name: '中秋节', date: new Date(currentYear, 8, 15) },
      { name: '国庆节', date: new Date(currentYear, 9, 1) },
      { name: '圣诞节', date: new Date(currentYear, 11, 25) }
    ]
    
    return holidays
      .map(holiday => ({
        ...holiday,
        date: new Date(currentYear, holiday.date.getMonth(), holiday.date.getDate())
      }))
      .filter(holiday => holiday.date >= today)
      .sort((a, b) => a.date.getTime() - b.date.getTime())
  }
}
```

### 6. 生命周期数据分析功能

### 6.1 功能概述

生命周期数据分析功能提供全面的客户生命周期数据分析，帮助管理者了解客户行为特征，优化客户管理策略，提升客户价值。

### 6.2 组件设计

#### 6.2.1 CustomerLifecycleAnalytics组件

**组件说明**：生命周期数据分析组件，提供关键指标展示、阶段分布分析、转化分析、同期群分析等功能。

**核心功能**：
- 关键指标展示
- 生命周期阶段分布分析
- 客户转化分析
- 同期群分析
- 客户生命周期价值分析
- 数据筛选和导出

**组件Props**：
```typescript
interface CustomerLifecycleAnalyticsProps {
  // 无Props
}
```

**组件Events**：
```typescript
interface CustomerLifecycleAnalyticsEmits {
  (e: 'filter-changed', filters: AnalyticsFilters): void
  (e: 'report-exported', reportType: string): void
}
```

**实现要点**：
- 使用el-card组件组织分析内容
- 使用el-row和el-col组件实现响应式布局
- 使用el-radio-group组件实现时间范围选择
- 使用el-empty组件作为图表占位符
- 使用el-dialog组件实现筛选对话框
- 实现数据分析计算逻辑

**关键指标计算**：
```typescript
function calculateKeyMetrics(customers: Customer[], timeRange: TimeRange): KeyMetrics {
  const filteredCustomers = filterCustomersByTimeRange(customers, timeRange)
  
  const totalCustomers = filteredCustomers.length
  const activeCustomers = filteredCustomers.filter(c => c.status === 'active').length
  const newCustomers = filteredCustomers.filter(c => {
    const daysSinceRegistration = Math.floor((Date.now() - new Date(c.createdAt).getTime()) / (1000 * 60 * 60 * 24))
    return daysSinceRegistration <= timeRange.days
  }).length
  const churnedCustomers = filteredCustomers.filter(c => {
    const daysSinceLastVisit = Math.floor((Date.now() - new Date(c.lastVisit).getTime()) / (1000 * 60 * 60 * 24))
    return daysSinceLastVisit > 90
  }).length
  
  const retentionRate = totalCustomers > 0 ? ((totalCustomers - churnedCustomers) / totalCustomers) * 100 : 0
  const avgCustomerValue = totalCustomers > 0 
    ? filteredCustomers.reduce((sum, c) => sum + (c.totalSpent || 0), 0) / totalCustomers 
    : 0
  
  return {
    totalCustomers,
    activeCustomers,
    newCustomers,
    churnedCustomers,
    retentionRate,
    avgCustomerValue,
    totalCustomersTrend: calculateTrend(customers, 'totalCustomers', timeRange),
    activeCustomersTrend: calculateTrend(customers, 'activeCustomers', timeRange),
    newCustomersTrend: calculateTrend(customers, 'newCustomers', timeRange),
    churnedCustomersTrend: calculateTrend(customers, 'churnedCustomers', timeRange),
    retentionRateTrend: calculateTrend(customers, 'retentionRate', timeRange),
    avgCustomerValueTrend: calculateTrend(customers, 'avgCustomerValue', timeRange)
  }
}

function calculateTrend(customers: Customer[], metric: string, timeRange: TimeRange): number {
  const currentPeriod = filterCustomersByTimeRange(customers, timeRange)
  const previousPeriod = filterCustomersByTimeRange(customers, {
    startDate: new Date(timeRange.startDate.getTime() - timeRange.days * 24 * 60 * 60 * 1000),
    endDate: timeRange.startDate
  })
  
  const currentValue = calculateMetricValue(currentPeriod, metric)
  const previousValue = calculateMetricValue(previousPeriod, metric)
  
  if (previousValue === 0) return 0
  return ((currentValue - previousValue) / previousValue) * 100
}

function calculateMetricValue(customers: Customer[], metric: string): number {
  switch (metric) {
    case 'totalCustomers':
      return customers.length
    case 'activeCustomers':
      return customers.filter(c => c.status === 'active').length
    case 'newCustomers':
      return customers.filter(c => c.isNew).length
    case 'churnedCustomers':
      return customers.filter(c => c.isChurned).length
    case 'retentionRate':
      const total = customers.length
      const churned = customers.filter(c => c.isChurned).length
      return total > 0 ? ((total - churned) / total) * 100 : 0
    case 'avgCustomerValue':
      return customers.length > 0 
        ? customers.reduce((sum, c) => sum + (c.totalSpent || 0), 0) / customers.length 
        : 0
    default:
      return 0
  }
}
```

**同期群分析算法**：
```typescript
function calculateCohortAnalysis(customers: Customer[], cohortPeriod: 'month' | 'quarter'): CohortAnalysis {
  const cohorts: Map<string, Cohort> = new Map()
  
  for (const customer of customers) {
    const cohortKey = getCohortKey(customer.createdAt, cohortPeriod)
    
    if (!cohorts.has(cohortKey)) {
      cohorts.set(cohortKey, {
        key: cohortKey,
        customers: [],
        retentionRates: [],
        avgValues: []
      })
    }
    
    cohorts.get(cohortKey)!.customers.push(customer)
  }
  
  const cohortArray = Array.from(cohorts.values()).sort((a, b) => 
    new Date(a.key).getTime() - new Date(b.key).getTime()
  )
  
  for (const cohort of cohortArray) {
    const retentionRates = calculateCohortRetentionRates(cohort.customers, cohortPeriod)
    const avgValues = calculateCohortAvgValues(cohort.customers, cohortPeriod)
    
    cohort.retentionRates = retentionRates
    cohort.avgValues = avgValues
  }
  
  return {
    cohorts: cohortArray,
    overallRetentionRate: calculateOverallRetentionRate(cohortArray),
    overallAvgValue: calculateOverallAvgValue(cohortArray)
  }
}

function getCohortKey(date: string, period: 'month' | 'quarter'): string {
  const d = new Date(date)
  if (period === 'month') {
    return `${d.getFullYear()}-${String(d.getMonth() + 1).padStart(2, '0')}`
  } else {
    const quarter = Math.floor(d.getMonth() / 3) + 1
    return `${d.getFullYear()}-Q${quarter}`
  }
}

function calculateCohortRetentionRates(customers: Customer[], period: 'month' | 'quarter'): number[] {
  const periods = 12
  const retentionRates: number[] = []
  
  for (let i = 0; i < periods; i++) {
    const periodStart = new Date(customers[0].createdAt)
    periodStart.setMonth(periodStart.getMonth() + i)
    
    const periodEnd = new Date(periodStart)
    periodEnd.setMonth(periodEnd.getMonth() + 1)
    
    const activeCustomers = customers.filter(c => {
      const lastVisit = new Date(c.lastVisit)
      return lastVisit >= periodStart && lastVisit < periodEnd
    }).length
    
    retentionRates.push((activeCustomers / customers.length) * 100)
  }
  
  return retentionRates
}

function calculateCohortAvgValues(customers: Customer[], period: 'month' | 'quarter'): number[] {
  const periods = 12
  const avgValues: number[] = []
  
  for (let i = 0; i < periods; i++) {
    const periodStart = new Date(customers[0].createdAt)
    periodStart.setMonth(periodStart.getMonth() + i)
    
    const periodEnd = new Date(periodStart)
    periodEnd.setMonth(periodEnd.getMonth() + 1)
    
    const periodCustomers = customers.filter(c => {
      const lastVisit = new Date(c.lastVisit)
      return lastVisit >= periodStart && lastVisit < periodEnd
    })
    
    const avgValue = periodCustomers.length > 0
      ? periodCustomers.reduce((sum, c) => sum + (c.totalSpent || 0), 0) / periodCustomers.length
      : 0
    
    avgValues.push(avgValue)
  }
  
  return avgValues
}
```

## 版本更新

### v2.0.0 (2025-01-20)
- 新增生命周期管理功能
- 新增RFM客户价值评估功能
- 新增客户流失预测功能
- 新增智能客户关怀提醒功能
- 新增生命周期数据分析功能
- 优化客户管理模块用户体验
- 完善文档内容

### v1.0.0 (2025-01-20)
- 初始版本发布
- 实现客户信息管理功能
- 实现客户状态跟踪功能
- 实现客户历史记录查询功能
- 实现客户分群管理功能
- 实现客户会员管理功能
- 实现客户数据导入导出功能
- 实现客户统计分析功能
